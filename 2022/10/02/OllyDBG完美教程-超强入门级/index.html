<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>OllyDBG完美教程(超强入门级) | FireKnight-HJ</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="FireKnight-HJ" type="application/atom+xml">
</head>

  
  <!-- 依赖于jquery和vue -->
  
    
<script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>

  

  
    
<script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>

  
  
  <body>
    <!-- 预加载动画 -->
    <!-- 页面预加载动画 -->

<div id='loader'>
  <link rel="stylesheet" href="/js/loaded/index.css" >
  <div class="loading-left-bg"></div>
  <div class="loading-right-bg"></div>
  <div class="spinner-box">
    <div class="configure-border-1">
      <div class="configure-core"></div>
    </div>
    <div class="configure-border-2">
      <div class="configure-core"></div>
    </div>
    <div class="loading-word">加载中...</div>
  </div>
</div>

<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
  
</script>

    
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (href, before, media, attributes) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header   " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="logo">
      <h3 class="drawer-box-head_title">FireKnight-HJ</h3>
      <h5 class="drawer-box-head_desc">fireknight-hJ的博客</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="logo">
        </div>
      
      <a href="/" class="logo">FireKnight-HJ</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('/medias/rand5.jpg')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        OllyDBG完美教程(超强入门级)
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2022-10-02 |
        </span>
      

      

      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content row justify-position" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="OllyDBG-完美教程-超强入门级"><a href="#OllyDBG-完美教程-超强入门级" class="headerlink" title="OllyDBG 完美教程(超强入门级)"></a><strong>OllyDBG</strong> <strong>完美教程</strong>(超强入门级)</h1><h2 id="基本结构与配置"><a href="#基本结构与配置" class="headerlink" title="基本结构与配置"></a>基本结构与配置</h2><p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002203248501.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002203248501.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002203248501"></p>
<ul>
<li><p><strong>反汇编窗口</strong>：显示被调试程序的反汇编代码，<strong>标题栏上的地址、 HEX 数据、反汇编、注释</strong>(可以通过在窗口中右击出现的菜单 <em>界面选项-&gt;隐藏标题</em> 或 <em>显示标题</em> 来进行切换是否显示)。用鼠标左键点击注释标签可以切换注释显示的方式。  </p>
</li>
<li><p><strong>寄存器窗口</strong>：显示当前所选线程的 CPU 寄存器内容。同样点击标签 <em>寄存器 (FPU)</em> 可以切换显示寄存器的方式。  </p>
</li>
<li><p><strong>信息窗口</strong>：显示反汇编窗口中选中的第一个命令的参数及一些跳转目标地址、字串等。  </p>
</li>
<li><p><strong>数据窗口</strong>：显示内存或文件的内容。右键菜单可用于切换显示方式。  </p>
</li>
<li><p><strong>堆栈窗口</strong>：显示当前线程的堆栈。  </p>
</li>
</ul>
<h3 id="修改UDD目录"><a href="#修改UDD目录" class="headerlink" title="修改UDD目录"></a>修改UDD目录</h3><p>这个 UDD 目录的作用是保存你调试的工作。比如你调试一个软件，设置了断点，添加了注释，一次没做完，这时 OllyDBG 就会把你所做的工作保存到这个 UDD 目录，以便你下次调试时可以继续以前的工作。如果不设置这个 UDD 目录， OllyDBG 默认是在其安装目录下保存这些后缀名为 udd 的文件，时间长了就会显的很乱，所以还是建议专门设置一个目录来保存这些文件。</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929193853185.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929193853185.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929193853185"></p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>OllyDBG 支持插件功能，插件的安装也很简单，只要把下载的插件（一般是个 DLL 文件）复制到 OllyDBG 安装目录下的 PLUGIN 目录中就可以了， OllyDBG 启动时会自动识别。要注意的是 OllyDBG 1.10 对插件的个数有限制，最多不能超过 32 个，否则会出错。建议插件不要添加的太多。</p>
<h2 id="基本调试与断点"><a href="#基本调试与断点" class="headerlink" title="基本调试与断点"></a>基本调试与断点</h2><p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929194220880.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929194220880.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929194220880"></p>
<p>调试中我们经常要用到的快捷键有这些：  </p>
<ul>
<li><p><code>F2</code>：<strong>设置断点</strong>，只要在光标定位的位置（上图中灰色条）按 F2 键即可，再按一次 F2 键则会<strong>删除断点</strong>。（相当于 SoftICE 中的 F9）  </p>
</li>
<li><p><code>F8</code>：<strong>单步步过</strong>。每按一次这个键<strong>执行一条</strong>反汇编窗口中的指令，遇到 <strong>CALL 等子程序不进入</strong>其代码。（相当于 SoftICE 中的 F10）</p>
</li>
<li><code>F7</code>：<strong>单步步入</strong>。功能同单步步过(F8)类似，区别是遇到 <strong>CALL 等子程序时会进入</strong>其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）</li>
<li><code>F4</code>：<strong>运行到选定位置</strong>。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）</li>
<li><code>F9</code>：<strong>运行</strong>。按下这个键<strong>如果没有设置相应断点</strong>的话，被调试的程序将<strong>直接开始运行</strong>。（相当于 SoftICE 中的 F5）</li>
<li><code>CTR+F9</code>：<strong>执行到返回</strong>。此命令<strong>在执行到一个 ret (返回指令)指令时暂停</strong>，<strong>常用于从系统领空返回到我们调试的程序领空</strong>。（相当于 SoftICE 中的 F12）</li>
<li><code>ALT+F9</code>：<strong>执行到用户代码</strong>。可用于<strong>从系统领空快速返回到我们调试的程序领空</strong>。（相当于 SoftICE 中的 F11）  </li>
</ul>
<p><em>要开始调试只需设置好断点，找到你感兴趣的代码段再按 F8 或 F7 键来一条条分析指令功能就可以了</em></p>
<h2 id="软件破解的流程"><a href="#软件破解的流程" class="headerlink" title="软件破解的流程"></a>软件破解的流程</h2><p><strong>软件破解的流程</strong>：拿到一个软件先别接着马上用 OllyDBG 调试，<strong>先运行</strong>一下，有帮助文档的最好先看一下帮助，<strong>熟悉一下软件的使用方法</strong>，再<strong>看看注册的方式</strong>。如果是序列号方式可以先输个假的来试一下，看看有什么反应，也给我们破解留下一些有用的线索。如果没有输入注册码的地方，要考虑一下是不是读取注册表或 Key 文件（一般称 keyfile，就是程序读取一个文件中的内容来判断是否注册），这些可以用其它工具来辅助分析。如果这些都不是，原程序只是一个功能不全的试用版，那要注册为正式版本就要自己来写代码完善了。  </p>
<p>获得程序的一些基本信息后，还要用查壳的工具来查一下程序是否加了壳，若没壳的话看看程序是什么编译器编的，如 VC、 Delphi、 VB 等。这样的查壳工具有 <strong>PEiD</strong> 和 <strong>FI</strong>。有壳的话我们要尽量脱了壳后再来用 OllyDBG 调试，特殊情况下也可带壳调试。  </p>
<h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>我们先来运行一下这个 crackme（用 PEiD 检测显示是 Delphi 编的），界面如图：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929201820212.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929201820212.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929201820212"></p>
<p>这个 crackme 已经把用户名和注册码都输好了，省得我们动手\^_\^。我们在那个“Register now !”按钮上点击一下，将会跳出一个对话框：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929201941181.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929201941181.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929201941181"></p>
<p>就从这个错误对话框中显示的“Wrong Serial, try again!”来入手。启动 OllyDBG，选择菜单 文件-&gt;打开 载入 CrackMe3.exe 文件，我们会停在这里：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202052671.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202052671.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929202052671"></p>
<p>在反汇编窗口中右击，出来一个菜单，我们在 查找-&gt;所有参考文本字串 上左键点击：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202152100.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202152100.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929202152100"></p>
<p>现在出来另一个对话框，我们在这个对话框里右击，选择“查找文本”菜单项，输入“Wrong Serial, try again!”的开头单词“Wrong”（注意这里查找内容要区分大小写）来查找，找到一处：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202231195.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202231195.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929202231195"></p>
<p>在我们找到的字串上右击，再在出来的菜单上点击“反汇编窗口中跟随”，我们来到这里：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202327817.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202327817.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929202327817"></p>
<p>为了看看是否还有其他的参考，可以通过选择右键菜单查找参考-&gt;立即数，会出来一个对话框：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202828003.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220929202828003.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220929202828003"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">00440F79 |. BA 8C104400 MOV EDX,CrackMe3.0044108C ; ASCII &quot;Wrong Serial,try again!&quot;</span><br><span class="line">00440F7E |. A1 442C4400 MOV EAX,DWORD PTR DS:[442C44]</span><br><span class="line">00440F83 |. 8B00 MOV EAX,DWORD PTR DS:[EAX]</span><br><span class="line">00440F85 |. E8 DEC0FFFF CALL CrackMe3.0043D068</span><br><span class="line">00440F8A |. EB 18 JMP SHORT CrackMe3.00440FA4</span><br><span class="line">00440F8C |&gt; 6A 00 PUSH 0</span><br><span class="line">00440F8E |. B9 80104400 MOV ECX,CrackMe3.00441080 ; ASCII &quot;Beggar off!&quot;00440F93 |. BA 8C104400 MOV EDX,CrackMe3.0044108C ; ASCII &quot;Wrong Serial,try again!&quot;</span><br><span class="line">00440F98 |. A1 442C4400 MOV EAX,DWORD PTR DS:[442C44]</span><br><span class="line">00440F9D |. 8B00 MOV EAX,DWORD PTR DS:[EAX]</span><br><span class="line">00440F9F |. E8 C4C0FFFF CALL CrackMe3.0043D068</span><br><span class="line">我们在反汇编窗口中向上滚动一下再看看：</span><br><span class="line">00440F2C |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line">00440F2F |. BA 14104400 MOV EDX,CrackMe3.00441014 ; ASCII &quot;Registered User&quot;</span><br><span class="line">00440F34 |. E8 F32BFCFF CALL CrackMe3.00403B2C ; 关键，要用 F7 跟进去</span><br><span class="line">00440F39 |. 75 51 JNZ SHORT CrackMe3.00440F8C ; 这里跳走就完蛋</span><br><span class="line">00440F3B |. 8D55 FC LEA EDX,DWORD PTR SS:[EBP-4]</span><br><span class="line">00440F3E |. 8B83 C8020000 MOV EAX,DWORD PTR DS:[EBX+2C8]</span><br><span class="line">00440F44 |. E8 D7FEFDFF CALL CrackMe3.00420E20</span><br><span class="line">00440F49 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line">00440F4C |. BA 2C104400 MOV EDX,CrackMe3.0044102C ; ASCII &quot;GFX-754-IER-954&quot;</span><br><span class="line">00440F51 |. E8 D62BFCFF CALL CrackMe3.00403B2C ; 关键，要用 F7 跟进去</span><br><span class="line">00440F56 |. 75 1A JNZ SHORT CrackMe3.00440F72 ; 这里跳走就完蛋</span><br><span class="line">00440F58 |. 6A 00 PUSH 0</span><br><span class="line">00440F5A |. B9 3C104400 MOV ECX,CrackMe3.0044103C ; ASCII &quot;CrackMe cr</span><br><span class="line">acked successfully&quot;</span><br><span class="line">00440F5F |. BA 5C104400 MOV EDX,CrackMe3.0044105C ; ASCII &quot;Congrats! Y</span><br><span class="line">ou cracked this CrackMe!&quot;</span><br><span class="line">00440F64 |. A1 442C4400 MOV EAX,DWORD PTR DS:[442C44]</span><br><span class="line">00440F69 |. 8B00 MOV EAX,DWORD PTR DS:[EAX]</span><br><span class="line">00440F6B |. E8 F8C0FFFF CALL CrackMe3.0043D068</span><br><span class="line">00440F70 |. EB 32 JMP SHORT CrackMe3.00440FA4</span><br><span class="line">00440F72 |&gt; 6A 00 PUSH 000440F74 |. B9 80104400 MOV ECX,CrackMe3.00441080 ; ASCII &quot;Beggar off!&quot;</span><br><span class="line">00440F79 |. BA 8C104400 MOV EDX,CrackMe3.0044108C ; ASCII &quot;Wrong Serial,try again!&quot;</span><br><span class="line">00440F7E |. A1 442C4400 MOV EAX,DWORD PTR DS:[442C44]</span><br><span class="line">00440F83 |. 8B00 MOV EAX,DWORD PTR DS:[EAX]</span><br><span class="line">00440F85 |. E8 DEC0FFFF CALL CrackMe3.0043D068</span><br><span class="line">00440F8A |. EB 18 JMP SHORT CrackMe3.00440FA4</span><br><span class="line">00440F8C |&gt; 6A 00 PUSH 0</span><br><span class="line">00440F8E |. B9 80104400 MOV ECX,CrackMe3.00441080 ; ASCII &quot;Beggar off!&quot;</span><br><span class="line">00440F93 |. BA 8C104400 MOV EDX,CrackMe3.0044108C ; ASCII &quot;Wrong Serial,try again!&quot;</span><br><span class="line">00440F98 |. A1 442C4400 MOV EAX,DWORD PTR DS:[442C44]</span><br><span class="line">00440F9D |. 8B00 MOV EAX,DWORD PTR DS:[EAX]</span><br><span class="line">00440F9F |. E8 C4C0FFFF CALL CrackMe3.0043D068</span><br></pre></td></tr></table></figure>
<p>注意看一下上面的注释，我在上面标了两个关键点。有人可能要问，你<strong>怎么知道那两个地方是关键点</strong>？其实很简单，我是<strong>根据查看是哪条指令跳到“wrong serial,try again”这条字串对应的指令来决定</strong>的。如果你在 <em>调试选项-&gt;CPU</em> 标签中把“<em>显示跳转路径</em>”及其下面的两个“<em>如跳转未实现则显示灰色路径</em>”、 “<em>显示跳转到选定命令的路径</em>”都选上的话，就会看到是从什么地方跳到出错字串处的：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930104939485.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930104939485.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930104939485"></p>
<p>我们在上图中地址 <strong>00440F2C</strong> 处按 <strong>F2 键设个断点</strong>，现在我们按 <strong>F9 键，程序已运行</strong>起来了。我在程序上面那个编辑框中随便输入一下，如 CCDebuger，下面那个编辑框我还保留为原来的“754-GFX-IER-954”，我们点一下那个“Register now !”按钮，呵， OllyDBG 跳了出来，<strong>暂停在我们下的断点处</strong>。我们看一下信息窗口，你应该发现了你刚才输入的内容了吧？我这里显示是这样：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆栈 SS:[0012F9AC]=00D44DB4, (ASCII &quot;CCDebuger&quot;)</span><br><span class="line">EAX=00000009</span><br></pre></td></tr></table></figure>
<p>上面的内存地址 00D44DB4 中就是我们刚才输入的内容，我这里是 CCDebuger。你可以在 堆栈 <code>SS:[0012F9AC]=00D44DB4, (ASCII &quot;CCDebuger&quot;)</code> 这条内容上左击选择一下，再点右键，在弹出菜单中选择“数据窗口中跟随数值”，你就会在下面的数据窗口中看到你刚才输入的内容。而 <code>EAX=00000009</code> 指的是你输入<strong>内容的长度</strong>。如我输入的 CCDebuger 是 9 个字符。如下图所示：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930105810498.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930105810498.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930105810498"></p>
<p>现在我们来按 F8 键一步步分析一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00440F2C |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4] ; 把我们输入的内容送到EAX，我这里是“CCDebuger”</span><br><span class="line">00440F2F |. BA 14104400 MOV EDX,CrackMe3.00441014 ; ASCII &quot;Registered User&quot;</span><br><span class="line">00440F34 |. E8 F32BFCFF CALL CrackMe3.00403B2C ; 关键，要用 F7 跟进去</span><br><span class="line">00440F39 |. 75 51 JNZ SHORT CrackMe3.00440F8C ; 这里跳走就完蛋</span><br></pre></td></tr></table></figure>
<p>当我们按 F8 键走到 <code>00440F34 |. E8 F32BFCFF CALL CrackMe3.00403B2C</code> 这一句时，我们按<br>一下 F7 键，进入这个 CALL，进去后光标停在这一句：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930110150046.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930110150046.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930110150046"></p>
<p>我们所看到的那些 PUSH EBX、 PUSH ESI 等都是调用子程序保存堆栈时用的指令，不用管它，按 F8 键一步步过来，我们只关心关键部分：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00403B2C /$ 53 PUSH EBX</span><br><span class="line">00403B2D |. 56 PUSH ESI</span><br><span class="line">00403B2E |. 57 PUSH EDI</span><br><span class="line">00403B2F |. 89C6 MOV ESI,EAX ; 把 EAX 内我们输入的用户名送到 ESI</span><br><span class="line">00403B31 |. 89D7 MOV EDI,EDX ; 把 EDX 内的数据“Registered User”送到 EDI</span><br><span class="line">00403B33 |. 39D0 CMP EAX,EDX ; 用“Registered User”和我们输入的用户名作比较</span><br><span class="line">00403B35 |. 0F84 8F000000 JE CrackMe3.00403BCA ; 相同则跳</span><br><span class="line">00403B3B |. 85F6 TEST ESI,ESI ; 看看 ESI 中是否有数据，主要是看看我们有没有输入用户名</span><br><span class="line">00403B3D |. 74 68 JE SHORT CrackMe3.00403BA7 ; 用户名为空则跳</span><br><span class="line">00403B3F |. 85FF TEST EDI,EDI</span><br><span class="line">00403B41 |. 74 6B JE SHORT CrackMe3.00403BAE</span><br><span class="line">00403B43 |. 8B46 FC MOV EAX,DWORD PTR DS:[ESI-4] ; 用户名长度送 EAX</span><br><span class="line">00403B46 |. 8B57 FC MOV EDX,DWORD PTR DS:[EDI-4] ; “Registered User”字串的长度送 EDX</span><br><span class="line">00403B49 |. 29D0 SUB EAX,EDX ; 把用户名长度和“Registered User”字串长度相减</span><br><span class="line">00403B4B |. 77 02 JA SHORT CrackMe3.00403B4F ; 用户名长度大于“Registered User”长度则跳</span><br><span class="line">00403B4D |. 01C2 ADD EDX,EAX ; 把减后值与“Registered User”长度相加，即用户名长度</span><br><span class="line">00403B4F |&gt; 52 PUSH EDX</span><br><span class="line">00403B50 |. C1EA 02 SHR EDX,2 ; 用户名长度值右移 2 位，这里相当于长度除以 4</span><br><span class="line">00403B53 |. 74 26 JE SHORT CrackMe3.00403B7B ; 上面的指令及这条指令就是判断用户名长度最少不能低于 4</span><br><span class="line">00403B55 |&gt; 8B0E MOV ECX,DWORD PTR DS:[ESI] ; 把我们输入的用户名送到ECX</span><br><span class="line">00403B57 |. 8B1F MOV EBX,DWORD PTR DS:[EDI] ; 把“Registered User”送到 EBX</span><br><span class="line">00403B59 |. 39D9 CMP ECX,EBX ; 比较</span><br><span class="line">00403B5B |. 75 58 JNZ SHORT CrackMe3.00403BB5 ; 不等则完蛋  </span><br></pre></td></tr></table></figure>
<p>根据上面的分析，我们知道<strong>用户名必须是“Registered User”</strong>。我们按 <strong>F9 键让程序运行</strong>，出现错误对话框，点确定，<strong>重新在第一个编辑框中输入“Registered User”</strong>，再次点击那个“Register now !”按钮，被 OllyDBG 拦下。因为地址 00440F34 处的那个 CALL 我们已经分析清楚了，这次就不用再按 F7 键跟进去了，<strong>直接按 F8 键通过</strong>。我们一路按 F8 键，<strong>来到第二个关键代码</strong>处：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00440F49 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4] ; 取输入的注册码</span><br><span class="line">00440F4C |. BA 2C104400 MOV EDX,CrackMe3.0044102C ; ASCII &quot;GFX-754-IER-954&quot;</span><br><span class="line">00440F51 |. E8 D62BFCFF CALL CrackMe3.00403B2C ; 关键，要用 F7 跟进去</span><br><span class="line">00440F56 |. 75 1A JNZ SHORT CrackMe3.00440F72 ; 这里跳走就完蛋</span><br></pre></td></tr></table></figure>
<p>大家注意看一下，地址 00440F51 处的 <code>CALL CrackMe3.00403B2C</code> 和上面我们分析的地址 00440F34 处的 <code>CALL CrackMe3.00403B2C</code> 是不是汇编指令都一样啊？这说明<strong>检测用户名和注册码是用的同一个子程序</strong>。而这个子程序 CALL 我们在上面已经分析过了。我们执行到现在可以很容易得出结论，这个 <strong>CALL</strong> 也就是<strong>把我们输入的注册码</strong>与 00440F4C 地址处指令后的<strong>“GFX-754-IER-954”作比较</strong>，相等则 OK。好了，我们已经得到足够的信息了。现在我们在菜单 <em>查看-&gt;断点</em> 上点击一下，打开断点窗口（也可以通过组合键 <em>ALT+B</em> 或点击工具栏上那个“<em>B”图标</em>打开断点窗口）：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930111645976.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930111645976.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930111645976"></p>
<p><em>为什么要做这一步，而不是把这个断点删除呢？这里主要是为了保险一点，万一分析错误，我们还要接着分析，要是把断点删除了就要做一些重复工作了。还是先禁用一下，如果经过实际验证证明我们的分析是正确的，再删不迟。</em></p>
<p>现在我们把断点禁用，在 OllyDBG 中按 F9 键让程序运行。输入我们经分析得出的内容 ：</p>
<blockquote>
<p>用户名： Registered User<br>注册码： GFX-754-IER-954  </p>
</blockquote>
<p>点击“<strong>Register now !”按钮</strong>，呵呵，终于成功了：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930111909147.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930111909147.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930111909147"></p>
<h2 id="函数参考"><a href="#函数参考" class="headerlink" title="函数参考"></a>函数参考</h2><p>现在进入第三篇，这一篇我们重点讲解怎样使用 OllyDBG 中的函数参考（即名称参考）功能。仍然选择 crackmes.cjb.net 镜像打包中的一个名称为 CrackHead 的 crackme。老规矩，先运行一下这个程序看看：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930112551097.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930112551097.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930112551097"></p>
<p>呵，竟然没找到输入注册码的地方！别急，我们点一下程序上的那个菜单“Shit”（真是 Shit 啊，呵呵），在下拉菜单中选“Try It”，会来到如下界面  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930112613273.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930112613273.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930112613273"></p>
<p>我们点一下那个“Check It”按钮试一下，哦，竟然没反应！我再输个“78787878”试试，还是没反应。再试试输入字母或其它字符，输不进去。由此<strong>判断注册码应该都是数字，只有输入正确的注册码才有动静</strong>。用 <strong>PEiD 检测一下，结果为 MASM32 / TASM32</strong>，怪不得程序比较小。信息收集的差不多了，现在关掉这个程序，我们用 <strong>OllyDBG 载入</strong>，按 F9 键直接让它运行起来，依次点击上面图中所说的菜单，使被调试程序显示如上面的第二个图。<strong>先不要点那个“Check It”</strong>按钮，保留上图的状态。</p>
<p>现在我们<strong>没有什么字串好参考</strong>了，我们就在 <strong>API 函数上下断点</strong>，来让被调试<strong>程序中断在我们希望的地方</strong>。我们在 OllyDBG 的反汇编窗口中右击鼠标，在弹出菜单中选择 <em>查找-&gt;当前模块中的名称 (标签)</em>，或者我们通过按 <em>CTR+N 组合键</em>也可以达到同样的效果（注意在进行此操作时要在 OllyDBG 中保证是在当前被调试程序的领空，我在第一篇中已经介绍了领空的概念，如我这里调试这个程序时 OllyDBG 的<strong>标题栏</strong>显示的就是“<strong>[CPU - 主线程, 模块 - CrackHea]</strong>”，这表明我们当前<strong>在被调试程序的领空</strong>）。通过上面的操作后会弹出一个对话框，如图：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930113105577.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930113105577.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930113105577"></p>
<p>对于这样的编辑框中输注册码的程序我们要设断点首选的 API 函数就是 <strong>GetDlgItemText</strong> 及 <strong>GetWindowText</strong>。每个函数都有<strong>两个版本</strong>，一个是 <strong>ASCII 版</strong>，在函数后<strong>添加一个 A</strong> 表示，如 <strong>GetDlgItemTextA</strong>，另一个是 <strong>UNICODE 版</strong>，在函数后<strong>添加一个 W</strong> 表示。如 <strong>GetDlgItemTextW</strong>。对于编译为 UNCODE 版的程序可能在 Win98 下不能运行，因为 Win98 并非是完全支持 UNICODE 的系统。而 NT 系统则从底层支持 UNICODE，它可以在操作系统内对字串进行转换，同时支持 ASCII 和 UNICODE 版本函数的调用。</p>
<p>一般我们打开的程序看到的调用都是 ASCII 类型的函数，以“A”结尾。又跑题了，呵呵。现在回到我们调试的程序上来，我们现在就是要找一下我们调试的程序<strong>有没有调用</strong> GetDlgItemTextA 或 GetWindowTextA 函数。还好，找到一个 GetWindowTextA。在这个函数上右击，在弹出菜单上选择“<em>在每个参考上设置断点</em>”，我们会在 OllyDBG 窗口最<strong>下面的那个状态栏</strong>里看到“<strong>已设置 2 个断点</strong>”。另一种方法就是那个 GetWindowTextA 函数上右击，在弹出菜单上选择“<em>查找输入函数参考</em>”（或者按回车键），将会出现下面的对话框：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930113215362.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930113215362.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930113215362"></p>
<p>看上图，我们<strong>可以把两条都设上断点</strong>。这个程序只需在第一条指令设断点就可以了。好，我们现在按前面提到的第一条方法，就是“在每个参考上设置断点”，这样上图中的两条指令都会设上断点。断点设好后我们转到我们调试的程序上来，现在我们在被我们调试的程序上点击那个“<em>Check It</em>”按钮，被 OllyDBG 断下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00401323 |. E8 4C010000 CALL &lt;JMP.&amp;USER32.GetWindowTextA&gt; ; GetWindowTextA</span><br><span class="line">00401328 |. E8 A5000000 CALL CrackHea.004013D2 ; 关键，要按 F7 键跟进去</span><br><span class="line">0040132D |. 3BC6 CMP EAX,ESI ; 比较</span><br><span class="line">0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ; 不等则完蛋</span><br><span class="line">00401331 |. EB 2C JMP SHORT CrackHea.0040135F</span><br><span class="line">00401333 |. 4E 6F 77 20 7&gt; ASCII &quot;Now write a keyg&quot;</span><br><span class="line">00401343 |. 65 6E 20 61 6&gt; ASCII &quot;en and tut and y&quot;</span><br><span class="line">00401353 |. 6F 75 27 72 6&gt; ASCII &quot;ou&amp;apos;re done.&quot;,0</span><br><span class="line">0040135F |&gt; 6A 00 PUSH 0 ; Style = MB_OK|MB_APPLMODAL</span><br><span class="line">00401361 |. 68 0F304000 PUSH CrackHea.0040300F ; Title = &quot;Crudd&amp;apos;s Crack Head&quot;</span><br><span class="line">00401366 |. 68 33134000 PUSH CrackHea.00401333 ; Text = &quot;Now write a keygen and tut and you&amp;apos;re done.&quot;</span><br><span class="line">0040136B |. FF75 08 PUSH DWORD PTR SS:[EBP+8] ; hOwner</span><br><span class="line">0040136E |. E8 19010000 CALL &lt;JMP.&amp;USER32.MessageBoxA&gt; ; MessageBoxA</span><br></pre></td></tr></table></figure>
<p>从上面的代码，我们很容易看出 00401328 地址处的 <code>CALL CrackHea.004013D2</code> 是关键，必须仔细跟踪。而注册成功则会显示一个对话框，标题是“Crudd’s Crack Head”，对话框显示的内容是“Now write a keygen and tut and you’re done.”现在我按一下 F8，准备步进到 00401328 地址处的那条 CALL CrackHea.004013D2 指令后再按 F7 键跟进去。等等，怎么回事？怎么按一下 F8 键跑到这来了：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401474 $- FF25 2C204000 JMP DWORD PTR DS:[&lt;&amp;USER32.GetWindowText&gt; ; USER32.GetWindowTextA</span><br><span class="line">0040147A $- FF25 30204000 JMP DWORD PTR DS:[&lt;&amp;USER32.LoadCursorA&gt;] ; USER32.LoadCursorA</span><br><span class="line">00401480 $- FF25 1C204000 JMP DWORD PTR DS:[&lt;&amp;USER32.LoadIconA&gt;] ; USER32.LoadIconA</span><br><span class="line">00401486 $- FF25 20204000 JMP DWORD PTR DS:[&lt;&amp;USER32.LoadMenuA&gt;] ; USER32.LoadMenuA</span><br><span class="line">0040148C $- FF25 24204000 JMP DWORD PTR DS:[&lt;&amp;USER32.MessageBoxA&gt;] ; USER32.MessageBoxA</span><br></pre></td></tr></table></figure>
<p>原来是跳到另一个断点了(之前一次性设置了两个断点)。这个断点我们不需要，按一下 F2 键删掉它吧。</p>
<p>删掉 00401474 地址处的断点后，我再按 F8 键，呵，完了，跑到 User32.dll 的领空了。看一下 OllyDBG 的标题栏： “<em>[CPU - 主线程, 模块 - USER32]</em>”，跑到系统领空了， OllyDBG 反汇编窗口中显示代码是这样：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">77D3213C 6A 0C PUSH 0C</span><br><span class="line">77D3213E 68 A021D377 PUSH USER32.77D321A0</span><br><span class="line">77D32143 E8 7864FEFF CALL USER32.77D185C0</span><br></pre></td></tr></table></figure>
<p>怎么办？别急，我们按一下 ALT+F9 组合键(快速回到用户领空)，呵，回来了：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401328 |. E8 A5000000 CALL CrackHea.004013D2 ; 关键，要按 F7 键跟进去</span><br><span class="line">0040132D |. 3BC6 CMP EAX,ESI ; 比较</span><br><span class="line">0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ;</span><br></pre></td></tr></table></figure>
<p>光标停在 00401328 地址处的那条指令上。现在我们按 F7 键跟进：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">004013D2 /$ 56 PUSH ESI ; ESI 入栈</span><br><span class="line">004013D3 |. 33C0 XOR EAX,EAX ; EAX 清零</span><br><span class="line">004013D5 |. 8D35 C4334000 LEA ESI,DWORD PTR DS:[4033C4] ; 把注册码框中的数值送到 ESI</span><br><span class="line">004013DB |. 33C9 XOR ECX,ECX ; ECX 清零</span><br><span class="line">004013DD |. 33D2 XOR EDX,EDX ; EDX 清零</span><br><span class="line">004013DF |. 8A06 MOV AL,BYTE PTR DS:[ESI] ; 把注册码中的每个字符送到 AL</span><br><span class="line">004013E1 |. 46 INC ESI ; 指针加 1，指向下一个字符</span><br><span class="line">004013E2 |. 3C 2D CMP AL,2D ; 把取得的字符与 16 进制值为2D 的字符(即“-”)比较，这里主要用于判断输入的是不是负数</span><br><span class="line">004013E4 |. 75 08 JNZ SHORT CrackHea.004013EE ; 不等则跳(不等说明没有负号，于是跳过对于负号的处理)</span><br><span class="line">004013E6 |. BA FFFFFFFF MOV EDX,-1 ; 如果输入的是负数，则把-1 送到 EDX，即 16 进制 FFFFFFFF</span><br><span class="line">004013EB |. 8A06 MOV AL,BYTE PTR DS:[ESI] ; 取“-”号后的第一个字符</span><br><span class="line">004013ED |. 46 INC ESI ; 指针加 1，指向再下一个字符</span><br><span class="line">004013EE |&gt; EB 0B JMP SHORT CrackHea.004013FB</span><br><span class="line">004013F0 |&gt; 2C 30 SUB AL,30 ; 每位字符减 16 进制的 30，因为这里都是数字，如 1 的 ASCII 码是“31H”，减 30H 后为 1，即我们平时看到的数值</span><br><span class="line">004013F2 |. 8D0C89 LEA ECX,DWORD PTR DS:[ECX+ECX*4] ; 把前面运算后保存在 ECX 中的结果乘 5 再送到 ECX</span><br><span class="line">004013F5 |. 8D0C48 LEA ECX,DWORD PTR DS:[EAX+ECX*2] ; 每位字符运算后的值与 2 倍上一位字符运算后值相加后送 ECX</span><br><span class="line">004013F8 |. 8A06 MOV AL,BYTE PTR DS:[ESI] ; 取下一个字符</span><br><span class="line">004013FA |. 46 INC ESI ; 指针加 1，指向再下一个字符</span><br><span class="line">004013FB |&gt; 0AC0 OR AL,AL</span><br><span class="line">004013FD |.^ 75 F1 JNZ SHORT CrackHea.004013F0 ; 上面一条和这一条指令主要是用来判断是否已把用户输入的注册码计算完</span><br><span class="line">004013FF |. 8D040A LEA EAX,DWORD PTR DS:[EDX+ECX] ; 把 EDX 中的值与经过上面运算后的 ECX 中值相加送到 EAX</span><br><span class="line">00401402 |. 33C2 XOR EAX,EDX ; 把 EAX 与 EDX 异或。如果我们输入的是负数，则此处功能就是把 EAX 中的值取反</span><br><span class="line">00401404 |. 5E POP ESI ; ESI 出栈(还原 004013D2 入栈的ESI数据)。看到这条和下一条指令，我们要考虑一下这个 ESI 的值是哪里运算得出的呢？</span><br><span class="line">00401405 |. 81F6 53757A79 XOR ESI,797A7553 ; 把 ESI中的值与 797A7553H 异或</span><br><span class="line">0040140B \. C3 RETN</span><br></pre></td></tr></table></figure>
<p>这里留下了一个问题：<strong>那个 ESI 寄存器中的值是从哪运算出来的？先不管这里</strong>，我们接着按 F8 键往下走，来到 0040140B 地址处的那条 RETN 指令（这里可以通过在调试选项的“命令”标签中勾选“使用 RET 代替 RETN”来更改返回指令的显示方式），再按一下 F8，我们就走出 00401328 地址处的那个 CALL 了。现在我们回到了这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040132D |. 3BC6 CMP EAX,ESI ; 比较</span><br><span class="line">0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ; 不等则完蛋</span><br></pre></td></tr></table></figure>
<p>光标停在了 0040132D 地址处的那条指令上。根据前面的分析，我们知道 <strong>EAX 中存放的是我们输入的注册码经过计算后的值</strong>。我们来看一下信息窗口：  </p>
<blockquote>
<p>ESI=E6B5F2F9<br>EAX=FF439EBE  </p>
</blockquote>
<p>左键选择信息窗口中的 ESI=E6B5F2F9，再按右键，在弹出菜单上选“修改寄存器”，我们会看到这样一个窗口：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930151534648.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930151534648.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930151534648"></p>
<p>可能你的显示跟我不一样，因为这个 crackme 中已经说了每个机器的序列号不一样。关掉上面的窗口，再对信息窗口中的 EAX=FF439EBE 做同样操作：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930151627994.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930151627994.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930151627994"></p>
<p>由上图我们知道了原来前面分析的对我们输入的注册码进行处理后的结果就是把字符格式转为数字格式。  </p>
<p>我们原来输入的是字串“12345666”，现在转换为了数字 12345666。这下就很清楚了，随便在上面那个修改 ESI 图中显示的有符号或无符号编辑框中复制一个，粘贴到我们调试的程序中的编辑框中试一下：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930151725005.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930151725005.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930151725005"></p>
<p>成功了。且慢高兴，这个 crackme 是要求写出注册机的。我们先不要求写注册机，但<strong>注册的算法</strong>我们要搞清楚。还记得我在前面说到的那个 ESI 寄存器值的问题吗？现在看看我们上面的分析，其实对做注册机来说是没有多少帮助的。要搞清注册算法，<strong>必须知道上面那个 ESI 寄存器值是如何产生的</strong>，这弄清楚后才能真正清楚这个 crackme 算法。今天就先说到这里，关于如何追出 ESI 寄存器的值我就留到下一篇－<strong>内存断点</strong> 中再讲吧。  </p>
<h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>还记得上一篇的内容吗？在那篇文章中我们分析后发现一个 <strong>ESI 寄存器值不知是从什么地方产生的</strong>，要弄清这个问题必须要<strong>找到生成这个 ESI 值的计算部分</strong>。今天我们的任务就是使用 OllyDBG 的内存断点功能找到这个地方，搞清楚这个值是如何算出来的。这次分析的目标程序还是上一篇的那个 crackme，附件我就不再上传了，用上篇中的附件就可以了。下面我们开始：还记得我们上篇中所说的关键代码的地方吗？温习一下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401323 |. E8 4C010000 CALL &lt;JMP.&amp;USER32.GetWindowTextA&gt; ; GetWin</span><br><span class="line">dowTextA</span><br><span class="line">00401328 |. E8 A5000000 CALL CrackHea.004013D2 ; 关键，要按 F7 键跟进去</span><br><span class="line">0040132D |. 3BC6 CMP EAX,ESI ; 比较</span><br><span class="line">0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ; 不等则完蛋</span><br></pre></td></tr></table></figure>
<p>我们重新用 OllyDBG 载入目标程序， F9 运行来到上面代码所在的地方（你上次设的断点应该没删吧？），我们向上看看能不能找到那个 ESI 寄存器中最近是在哪里赋的值。哈哈，原来就在附近啊：</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930160128487.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930160128487.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930160128487"></p>
<p>我们现在知道 <strong>ESI 寄存器的值是从内存地址 40339C 中送过来的</strong>，那内存地址 40339C 中的数据是什么时候产生的呢？大家注意，我这里信息窗口中显示的是 DS:[0040339C]=9FCF87AA，你那可能是 DS:[0040339C]=XXXXXXXX，这里的 XXXXXXXX 表示的是其它的值，就是说与我这里显示的 9FCF87AA 不一样。我们按上图的操作在数据窗口中看一下：</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930160653906.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930160653906.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930160653906"></p>
<p>从上图我们可以看出内存地址 40339C 处的值已经有了，说明早就算过了。现在怎么办呢？我们考虑一下，看情况<strong>程序是把这个值算出来以后写在这个内存地址</strong>，那我们要是能让 OllyDBG <strong>在程序开始往这个内存地址写东西的时候中断下来</strong>，不就有可能知道目标程序是怎么算出这个值的吗？说干就干，我们在 OllyDBG 的菜单上点 <em>调试-&gt;重新开始</em>，或者按 <em>CTR+F2 组合键</em>（还可以点击工具栏上的那个有两个实心左箭头的图标）来重新载入程序。这时会跳出一个“进程仍处于激活状态”的对话框（我们可以在在调试选项的安全标签下把“终止活动进程时警告”这条前面的勾去掉，这样下次就不会出现这个对话框了），问我们是否要终止进程。这里我们选“是”，程序被重新载入，我们停在下面这一句上：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401000 &gt;/$ 6A 00 PUSH 0 ; pModule = NULL</span><br></pre></td></tr></table></figure>
<p>现在我们就要来设内存断点了。在 OllyDBG 中一般我们用到的内存断点有<strong>内存访问和内存写入断点</strong>。内存访问断点就是指程序<strong>访问内存中我们指定的内存地址时中断</strong>，内存写入断点就是指程序往我们<strong>指定的内存地址中写东西时中断</strong>。</p>
<p><em>更多关于断点的知识大家可以参考这篇 Lenus 兄弟写的《如何对抗硬件断点之一 —- 调试寄存器》文章（<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-10829.htm），也可以看这个帖：">https://bbs.pediy.com/thread-10829.htm），也可以看这个帖：</a> <a target="_blank" rel="noopener" href="http://bbs.pediy.com/showthread.php?threadid=10829。">http://bbs.pediy.com/showthread.php?threadid=10829。</a></em></p>
<p>根据当前我们调试的具体程序的情况，我们选用内存写入断点。还记得前面我叫大家记住的那个 40339C 内存地址吗？现在我们要用上了。我们先在 OllyDBG 的数据窗口中左键点击一下，再右击，会弹出一个如下图所示的菜单。我们选择其中的<em>转到-&gt;表达式</em>（也可以左键点击数据窗口后按 <em>CTR+G 组合键</em>）。如下图：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930161433894.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930161433894.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930161433894"></p>
<p>现在将会出现这样一个对话框：<br>我们在上面那个编辑框中输入我们想查看内容的内存地址 40339C，然后点确定按钮，数据窗口中显示如下：</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930162333637.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930162333637.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930162333637"></p>
<p>我们可以看到， 40339C 地址开始处的这段内存里面还没有内容。我们现在在 40339C 地址处后面的 HEX 数据或 ASCII 栏中<strong>按住左键往后拖放，选择一段</strong>。内存断点的特性就是不管你选几个字节， <strong>OllyDBG 都会分配 4096 字节的内存区</strong>。这里我就选从 40339C 地址处开始的四个字节，主要是为了让大家提前了解一下硬件断点的设法，因为<strong>硬件断点最多只能选 4 个字节</strong>。<strong>选中部分会显示为灰色</strong>。选好以后松开鼠标左键，在我们选中的灰色部分上右击：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930163121144.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930163121144.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930163121144"></p>
<p>经过上面的操作，我们的内存断点就设好了（这里还有个要注意的地方：内存断点<strong>只在当前调试的进程中有效，</strong>就是说你<strong>如果重新载入程序的话内存断点就自动删除</strong>了。且内存断点<strong>每一时刻只能有一个</strong>。就是说你不能像按 F2 键那样同时设置多个断点）。现在按 F9 键让程序运行，呵， OllyDBG 中断了！  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">7C932F39 8808 MOV BYTE PTR DS:[EAX],CL ; 这就是我们第一次断下来的地方</span><br><span class="line">7C932F3B 40 INC EAX</span><br><span class="line">7C932F3C 4F DEC EDI</span><br><span class="line">7C932F3D 4E DEC ESI</span><br><span class="line">7C932F3E ^ 75 CB JNZ SHORT ntdll.7C932F0B</span><br><span class="line">7C932F40 8B4D 10</span><br></pre></td></tr></table></figure>
<p>上面就是我们中断后反汇编窗口中的代码。如果你是其它系统，如 Win98 的话，可能会有所不同。没关系，这里不是关键。我们看一下领空，原来是<strong>在 ntdll.dll 内</strong>。<strong>系统领空</strong>，我们现在要考虑返回到程序领空。返回前我们看一下数据窗口：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930163853536.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930163853536.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930163853536"></p>
<p>现在我们转到反汇编窗口，右击鼠标，在弹出菜单上选择<em>断点-&gt;删除内存断点</em>，这样内存断点就被删除了  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930164049303.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930164049303.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930164049303"></p>
<p>现在我们来按一下 ALT+F9 组合键，我们来到下面的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401431 |. 8D35 9C334000 LEA ESI,DWORD PTR DS:[40339C] ; ALT+F9 返回后来到的位置</span><br><span class="line">00401437 |. 0FB60D EC334000 MOVZX ECX,BYTE PTR DS:[4033EC]</span><br><span class="line">0040143E |. 33FF XOR EDI,EDI  </span><br></pre></td></tr></table></figure>
<p>我们把反汇编窗口往上翻翻，呵，原来就在我们上一篇分析的代码下面啊？  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930164343340.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930164343340.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930164343340"></p>
<p>现在我们在 0040140C 地址处那条指令上按 F2 设置一个断点，现在我们按 CTR+F2 组合键重新载入程序，载入后按 F9 键运行，我们将会中断在我们刚才在 0040140C 地址下的那个断点处：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0040140C /$ 60 PUSHAD</span><br><span class="line">0040140D |. 6A 00 PUSH 0 ; /RootPathName = NULL</span><br><span class="line">0040140F |. E8 B4000000 CALL &lt;JMP.&amp;KERNEL32.GetDriveTypeA&gt; ; \GetDriveTypeA</span><br><span class="line">00401414 |. A2 EC334000 MOV BYTE PTR DS:[4033EC],AL ; 磁盘类型参数送内存地址 4033EC</span><br><span class="line">00401419 |. 6A 00 PUSH 0 ; /pFileSystemNameSize = NULL</span><br><span class="line">0040141B |. 6A 00 PUSH 0 ; |pFileSystemNameBuffer = NULL</span><br><span class="line">0040141D |. 6A 00 PUSH 0 ; |pFileSystemFlags = NULL</span><br><span class="line">0040141F |. 6A 00 PUSH 0 ; |pMaxFilenameLength = NULL</span><br><span class="line">00401421 |. 6A 00 PUSH 0 ; |pVolumeSerialNumber = NULL</span><br><span class="line">00401423 |. 6A 0B PUSH 0B ; |MaxVolumeNameSize = B (11.)00401425 |. 68 9C334000 PUSH CrackHea.0040339C|VolumeNameBuffer = CrackHea.0040339C</span><br><span class="line">0040142A |. 6A 00 PUSH 0 ; |RootPathName = NULL</span><br><span class="line">0040142C |. E8 A3000000 CALL &lt;JMP.&amp;KERNEL32.GetVolumeInformationA&gt; ; \GetVolumeInformationA</span><br><span class="line">00401431 |. 8D35 9C334000 LEA ESI,DWORD PTR DS:[40339C] ; 把 crackme 程序所在分区的卷标名称送到 ESI</span><br><span class="line">00401437 |. 0FB60D EC334000 MOVZX ECX,BYTE PTR DS:[4033EC] ; 磁盘类型参数送 ECX</span><br><span class="line">0040143E |. 33FF XOR EDI,EDI ; 把 EDI 清零</span><br><span class="line">00401440 |&gt; 8BC1 MOV EAX,ECX ; 磁盘类型参数送 EAX</span><br><span class="line">00401442 |. 8B1E MOV EBX,DWORD PTR DS:[ESI] ; 把卷标名作为数值送到 EBX</span><br><span class="line">00401444 |. F7E3 MUL EBX ; 循环递减取磁盘类型参数值与卷标名值相乘</span><br><span class="line">00401446 |. 03F8 ADD EDI,EAX ; 每次计算结果再加上上次计算结果保存在 EDI 中</span><br><span class="line">00401448 |. 49 DEC ECX ; 把磁盘类型参数作为循环次数，依次递减</span><br><span class="line">00401449 |. 83F9 00 CMP ECX,0 ; 判断是否计算完</span><br><span class="line">0040144C |.^ 75 F2 JNZ SHORT CrackHea.00401440 ; 没完继续</span><br><span class="line">0040144E |. 893D 9C334000 MOV DWORD PTR DS:[40339C],EDI ; 把计算后值送到内存地址 40339C，这就是我们后来在 ESI 中看到的值</span><br><span class="line">00401454 |. 61 POPAD</span><br><span class="line">00401455 \. C3 RETN</span><br></pre></td></tr></table></figure>
<p>通过上面的分析，我们知道基本算法是这样的：先用 GetDriveTypeA 函数获取磁盘类型参数，再用 GetVolumeInformationA 函数获取这个 crackme 程序所在分区的卷标。如我把这个 Crackme 程序放<br>在 F:\OD 教程\crackhead\ 目录下，而我 F 盘设置的卷标是 GAME，则这里获取的就是 GAME， ASCII 码为“47414D45”。但我们发现一个问题：假如原来我们在数据窗口中看到的地址 40339C 处的 16 进制代码是“47414D45”，即“GAME”， 但经过地址 00401442 处的那条 MOV EBX,DWORD PTR DS:[ESI] 指令后，我们却发现 EBX 中的值是“454D4147”，正好把我们上面那个“47414D45”反过来了。为什么会这样呢？如果大家对 x86 系列 CPU 的存储方式了解的话，这里就容易理解了。我们知道“GAME”有四个字节，即 ASCII 码为“47414D45”。我们看一下数据窗口中的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040339C 47 41 4D 45 00 00 00 00 00 00 00 00 00 00 00 00 GAME............</span><br></pre></td></tr></table></figure>
<p>大家可以看出来内存地址 40339CH 到 40339FH 分别按顺序存放的是 47 41 4D 45。<br>如下图：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930170807922.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930170807922.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930170807922"></p>
<p><strong>系统存储的原则为“高高低低”</strong>，即<strong>低字节存放在地址较低的字节单元</strong>中，<strong>高字节存放在地址较高的字节单元</strong>中。比如一个字由两个字节组成，像这样： 12 34 ，这里的高字节就是 12 ，低字节就是 34。上面的那条指令 MOV EBX,DWORD PTR DS:[ESI] 等同于 MOV EBX,DWORD PTR DS:[40339C]。注意这里是 <strong>DWORD，即“双字”，由 4 个连续的字节构成</strong>。而取地址为 40339C 的双字单元中的内容时，我们应该得到的是“454D4147”，即<strong>由高字节到低字节顺序的值</strong>。因此经过 MOV EBX,DWORD PTR DS:[ESI] 这条指令，就是把从地址 40339C 开始处的值送到 EBX，所以我们得到了“454D4147”。好了，这里弄清楚了，我们再接着谈这个程序的算法。前面我们已经说了<strong>取磁盘类型参数做循环次数</strong>，再<strong>取卷标值 ASCII 码的逆序作为数值</strong>，有了这两个值就开始计算了。现在我们把磁盘类型值作为 n，卷标值 ASCII 码的逆序数值作为 a，最后得出的结果作为 b，有这样的计算过程：  </p>
<blockquote>
<p>第一次： b = a <em> n<br>第二次： b = a </em> (n - 1) + b<br>第三次： b = a * (n - 2) + b<br>… </p>
<p>第 n 次： b = a <em> 1 + b<br>可得出公式为 b = a </em> [n + (n - 1) + (n - 2) + … + 1] = a <em> [n </em> (n + 1) / 2]  </p>
</blockquote>
<p>还记得上一篇我们的分析吗？看这一句：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401405 |. 81F6 53757A79 XOR ESI,797A7553 ; 把 ESI中的值与 797A7553H 异或  </span><br></pre></td></tr></table></figure>
<p>这里算出来的 b 最后还要和 797A7553H 异或一下才是真正的注册码。只要你对编程有所了解，这个注册机就很好写了。如果用汇编来写这个注册机的话就更简单了，很多内容可以直接照抄。  </p>
<p>到此已经差不多了，最后还有几个东西也说一下吧：  </p>
<ol>
<li>上面用到了两个 API 函数，一个是 GetDriveTypeA，还有一个是 GetVolumeInformationA，关于这两个函数的具体用法我就不多说了，大家可以查一下 MSDN。这里只要大家注意函数参数传递的次序，即调用约定。先看一下这里：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00401419 |. 6A 00 PUSH 0 ; /pFileSystemNameSize = NULL</span><br><span class="line">0040141B |. 6A 00 PUSH 0 ; |pFileSystemNameBuffer = NULL</span><br><span class="line">0040141D |. 6A 00 PUSH 0 ; |pFileSystemFlags = NULL</span><br><span class="line">0040141F |. 6A 00 PUSH 0 ; |pMaxFilenameLength = NULL</span><br><span class="line">00401421 |. 6A 00 PUSH 0 ; |pVolumeSerialNumber = NULL</span><br><span class="line">00401423 |. 6A 0B PUSH 0B ; |MaxVolumeNameSize = B (11.)</span><br><span class="line">00401425 |. 68 9C334000 PUSH CrackHea.0040339C ; |VolumeNameBuffer = CrackHea.0040339C</span><br><span class="line">0040142A |. 6A 00 PUSH 0 ; |RootPathName = NULL</span><br><span class="line">0040142C |. E8 A3000000 CALL &lt;JMP.&amp;KERNEL32.GetVolumeInformationA&gt; ; \GetVolumeInformationA</span><br></pre></td></tr></table></figure>
<p>把上面代码后的 OllyDBG 自动添加的注释与 MSDN 中的函数原型比较一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetVolumeInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpRootPathName, <span class="comment">// address of root directory of the file system</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpVolumeNameBuffer, <span class="comment">// address of name of the volumeDWORD nVolumeNameSize, // length of lpVolumeNameBuffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpVolumeSerialNumber, <span class="comment">// address of volume serial number</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpMaximumComponentLength, <span class="comment">// address of system&amp;apos;s maximum filename length</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpFileSystemFlags, <span class="comment">// address of file system flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpFileSystemNameBuffer, <span class="comment">// address of name of file system</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nFileSystemNameSize <span class="comment">// length of lpFileSystemNameBuffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>大家应该看出来点什么了吧？<strong>函数调用是先把最后一个参数压栈，参数压栈顺序是从后往前</strong>。这就是一般比较常见的 stdcall 调用约定。  </p>
<ol>
<li>我在前面的 00401414 地址处的那条 MOV BYTE PTR DS:[4033EC],AL 指令后加的注释是“磁盘类型参数送内存地址 4033EC”。为什么这样写？大家把前一句和这一句合起来看一下：  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040140F |. E8 B4000000 CALL &lt;JMP.&amp;KERNEL32.GetDriveTypeA&gt; ; \GetDriveTypeA</span><br><span class="line">00401414 |. A2 EC334000 MOV BYTE PTR DS:[4033EC],AL ; 磁盘类型参数送内存地址 4033EC</span><br></pre></td></tr></table></figure>
<p>地址 0040140F 处的那条指令是调用 <code>GetDriveTypeA</code> 函数，一般函数调用后的返回值都保存在 EAX 中，所以地址 00401414 处的那一句 MOV BYTE PTR DS:[4033EC],AL 就是传递返回值。查一下 MSDN 可以知道 GetDriveTypeA 函数的返回值有这几个：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
<th>返回在 EAX 中的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>DRIVE_UNKNOWN</td>
<td>The drive type cannot be determined.</td>
<td>0</td>
</tr>
<tr>
<td>DRIVE_NO_ROOT_DIR</td>
<td>The root directory does not exist.</td>
<td>1</td>
</tr>
<tr>
<td>DRIVE_REMOVABLE</td>
<td>The disk can be removed from the drive.</td>
<td>2</td>
</tr>
<tr>
<td>DRIVE_FIXED</td>
<td>The disk cannot be removed from the drive.</td>
<td>3</td>
</tr>
<tr>
<td>DRIVE_REMOTE</td>
<td>The drive is a remote (network) drive.</td>
<td>4</td>
</tr>
<tr>
<td>DRIVE_CDROM</td>
<td>The drive is a CD-ROM drive.</td>
<td>5</td>
</tr>
<tr>
<td>DRIVE_RAMDISK</td>
<td>The drive is a RAM disk.</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<p>上面那个“返回在 EAX 中的值”是我加的，<strong>我这里返回的是 3，即磁盘不可从驱动器上删除</strong>。</p>
<ol>
<li>通过分析这个程序的算法，我们发现这个注册算法是有漏洞的。如果我的分区没有卷标的话，则卷标值为 0，最后的注册码就是 797A7553H，即十进制 2038068563。而如果你的卷标和我一样，且磁盘类型一样的话，注册码也会一样，并不能真正做到一机一码。</li>
</ol>
<h2 id="消息断点及-RUN-跟踪"><a href="#消息断点及-RUN-跟踪" class="headerlink" title="消息断点及 RUN 跟踪"></a>消息断点及 RUN 跟踪</h2><p>找了几十个不同语言编写的 crackme，发现只用消息断点的话有很多并不能真正到达我们要找的关键位置，想想还是把消息断点和 RUN 跟踪结合在一起讲，更有效一点。关于消息断点的更多内容大家可以参考 jingulong 兄的那篇《几种典型程序 Button 处理代码的定位》的文章，堪称经典之作(<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-20078.htm)。">https://bbs.pediy.com/thread-20078.htm)。</a></p>
<p>今天仍然选择 <strong>crackmes.cjb.net</strong> 镜像打包中的一个名称为 <strong>cycle</strong> 的 crackme。按照惯例，我们先运行一下这个程序看看：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930203031458.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20220930203031458.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20220930203031458"></p>
<p>我们输入用户名 CCDebuger，序列号 78787878，点上面那个“Check”按钮，呵， 没反应！看来是要注册码正确才有动静。现在关掉这个 crackme，用 PEiD 查一下壳，原来是 MASM32 / TASM32 [Overlay]。启动 OllyDBG 载入这个程序， F9 让它运行。</p>
<p>这个程序按我们前面讲的<strong>采用字串参考或函数参考的方法都很容易断下来</strong>。但我们今天主要学习的是<strong>消息断点</strong>及 <strong>RUN 跟踪</strong>，就先用消息断点来断这个程序吧。在设消息断点前，有两个内容我们要简单了解一下：首先我们要了解的是消息。 Windows 的中文翻译就是“窗口”，而 Windows 上面的应用程序也都是通过窗口来与用户交互的。现在就有一个问题，<strong>应用程序是如何知道用户作了什么样的操作的？这里就要用到消息了</strong>。 <strong>Windows 是个基于消息的系统</strong>，它在应用程序开始执行后，为该程序创建一个“<strong>消息队列</strong>”，用来<strong>存放该程序可能创建的各种不同窗口的信息</strong>。比如你创建窗口、点击按钮、移动鼠标等等，都是通过消息来完成的。通俗的说， <strong>Windows 就像一个中间人，你要干什么事是先通知它，然后它才通过传递消息的方式通知应用程序作出相应的操作</strong>。说到这，又有个问题了，在 Windows 下有多个程序都在运行，那我点了某个按钮，或把某个窗口最大化， Windows 知道我是点的哪个吗？这里就要说到另一个内容：<strong>句柄（handle）</strong>了。<strong>句柄一般是个 32 位的数，表示一个对象</strong>。 Windows 通过使用句柄来标识它代表的对象。<strong>比如你点击某个按钮， Windows 就是通过句柄来判断你是点击了那一个按钮</strong>，<strong>然后发送相应的消息通知程序</strong>。</p>
<p>说完这些我们再回到我们调试的程序上来，你应该已经用 OllyDBG 把这个 crackme 载入并按 F9 键运行了吧？现在我们输入用户名“CCDebuger”，序列号“78787878”，先不要点那个“Check”按钮，我们来到 OllyDBG 中，点击菜单 <em>查看-&gt;窗口</em>（或者点击工具栏上那个“W”的图标），我们会看到以下内容：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010114933.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010114933.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002010114933"></p>
<p>我们在选中的条目上点右键，再选择上图所示的菜单项，会来到下面这个窗口：  </p>
<p>现在我们点击图上的那个下拉菜单，呵，原来里面的消息真不少。这么多消息我们选哪个呢？注册是个按钮，我们就在按下按钮再松开时让程序中断。查一下 MSDN，我们知道这个消息应该是 WM_LBUTTON_UP，看字面意思也可以知道是左键松开时的消息：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010228461.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010228461.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002010228461"></p>
<p>从下拉菜单中选中那个 <code>202 WM_LBUTTON_UP</code>，再按<em>确定按钮</em>，我们的消息断点就设好了。现在我们还要做一件事，就是<strong>把 RUN 跟踪打开</strong>。有人可能要问，这个 RUN 跟踪是干什么的？简单的说， <strong>RUN 跟踪就是把被调试程序执行过的指令保存下来</strong>，让你可以查看被调试程序运行期间干了哪些事。 <strong>RUN 跟踪会把地址、寄存器的内容、消息以及已知的操作数记录到 RUN 跟踪缓冲区中</strong>，你可以通过查看 RUN 跟踪的记录来了解程序执行了那些指令。在这还要注意一个缓冲区大小的问题，如果执行的指令太多，缓冲区满了的话，就会自动丢弃前面老的记录。我们可以在调试选项-&gt;跟踪中设置：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010443815.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010443815.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002010443815"></p>
<p>现在我们回到 OllyDBG 中，点击<em>菜单调试-&gt;打开或清除 RUN 跟踪</em>（第一次点这个菜单是打开 RUN 跟踪，在打开的情况下点击就是清除 RUN 跟踪的记录，对 RUN 跟踪熟悉时还可以设置条件），保证当前在我们调试的程序领空，在反汇编窗口中点击右键，在弹出菜单中选择 <em>RUN 跟踪-&gt;添加所有函数过程的入口</em>：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010622958.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010622958.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002010622958"></p>
<p>我们可以看到 OllyDBG 把识别出的函数过程都在前面加了灰色条：</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010641506.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010641506.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002010641506"></p>
<p>现在我们回到那个 crackme 中按那个“Check”按钮，被 OllyDBG 断下了：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010649820.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010649820.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002010649820"></p>
<p>这时我们点击菜单查看-&gt;内存，或者点击工具栏上那个“M”按钮（也可以按组合键 ALT+M），来到内存映射窗口：</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010705583.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002010705583.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002010705583"></p>
<p>为什么在这里设访问断点，我也说一下。我们可以看一下常见的 PE 文件，没加过壳的用 PEiD 检测是这样：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002130135520.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002130135520.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002130135520"></p>
<p>点一下 EP 段后面那个“&gt;”符号，我们可以看到以下内容：</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002131726088.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002131726088.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002131726088"></p>
<p>看完上面的图我们应该了解为什么在 401000 处的代码段下访问断点了，我们这里的意思就是在消息断点断下后，<strong>只要按 F9 键运行时执行到程序代码段的指令我们就中断</strong>，<strong>这样就可以回到程序领空了</strong>（当然在 401000 处所在的段不是绝对的，我们主要是要看程序的代码段在什么位置，其实在上面图中 OllyDBG 内存窗口的“包含”栏中我们就可以看得很清楚了）。设好访问断点后我们按 F9 键，被 OllyDBG 断下：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002133424002.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002133424002.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002133424002"></p>
<p>现在我们先不管，按 F9 键（或者按 <code>CTR+F12 组合键</code>跟踪步过）让程序运行，再点击菜单查看-&gt;RUN 跟踪，或者点击工具栏上的那个“…”符号，打开 RUN 跟踪的记录窗口看看：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002160146205.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002160146205.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002160146205"></p>
<p>我们现在再来看看统计的情况：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002160201987.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002160201987.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002160201987"></p>
<p>在地址 401082 处的那条指令上双击一下，来到以下位置：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002160351653.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002160351653.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002160351653"></p>
<p>现在我们在地址 4010A6 处的那条指令上按 F2，删除所有其它的断点，点<em>菜单调试-&gt;关闭 RUN 跟踪</em>，现在我们就可以开始分析了：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">004010E2 |. 8BFE MOV EDI,ESI ; 用户名送 EDI</span><br><span class="line">004010E4 |. 03F8 ADD EDI,EAX</span><br><span class="line">004010E6 |. FC CLD</span><br><span class="line">004010E7 |. F3:A4 REP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]</span><br><span class="line">004010E9 |. 33C9 XOR ECX,ECX ; 清零，设循环计数器</span><br><span class="line">004010EB |. BE 71214000 MOV ESI,cycle.00402171 ; 注册码送 ESI</span><br><span class="line">004010F0 |&gt; 41 INC ECX</span><br><span class="line">004010F1 |. AC LODS BYTE PTR DS:[ESI] ; 取注册码的每个字符</span><br><span class="line">004010F2 |. 0AC0 OR AL,AL ; 判断是否为空</span><br><span class="line">004010F4 |. 74 0A JE SHORT cycle.00401100 ; 没有则跳走</span><br><span class="line">004010F6 |. 3C 7E CMP AL,7E ; 判断字符是否为非 ASCII 字符</span><br><span class="line">004010F8 |. 7F 06 JG SHORT cycle.00401100 ; 非 ASCII 字符跳走</span><br><span class="line">004010FA |. 3C 30 CMP AL,30 ; 看是否小于 30H，主要是判断是不是数字或字母等</span><br><span class="line">004010FC |. 72 02 JB SHORT cycle.00401100 ; 小于跳走</span><br><span class="line">004010FE |.^ EB F0 JMP SHORT cycle.004010F0</span><br><span class="line">00401100 |&gt; 83F9 11 CMP ECX,11 ; 比较注册码位数，必须为十进制 17 位</span><br><span class="line">00401103 |. 75 1A JNZ SHORT cycle.0040111F</span><br><span class="line">00401105 |. E8 E7000000 CALL cycle.004011F1 ; 关键， F7 跟进去</span><br><span class="line">0040110A |. B9 01FF0000 MOV ECX,0FF01</span><br><span class="line">0040110F |. 51 PUSH ECX</span><br><span class="line">00401110 |. E8 7B000000 CALL cycle.00401190 ; 关键，跟进去</span><br><span class="line">00401115 |. 83F9 01 CMP ECX,1</span><br><span class="line">00401118 |. 74 06 JE SHORT cycle.00401120</span><br><span class="line">0040111A |&gt; E8 47000000 CALL cycle.00401166 ; 注册失败对话框</span><br><span class="line">0040111F |&gt; C3 RETN</span><br><span class="line">00401120 |&gt; A1 68214000 MOV EAX,DWORD PTR DS:[402168]</span><br><span class="line">00401125 |. 8B1D 6C214000 MOV EBX,DWORD PTR DS:[40216C]</span><br><span class="line">0040112B |. 33C3 XOR EAX,EBX</span><br><span class="line">0040112D |. 3305 82214000 XOR EAX,DWORD PTR DS:[402182]</span><br><span class="line">00401133 |. 0D 40404040 OR EAX,40404040</span><br><span class="line">00401138 |. 25 77777777 AND EAX,77777777</span><br><span class="line">0040113D |. 3305 79214000 XOR EAX,DWORD PTR DS:[402179]</span><br><span class="line">00401143 |. 3305 7D214000 XOR EAX,DWORD PTR DS:[40217D]</span><br><span class="line">00401149 |.^ 75 CF JNZ SHORT cycle.0040111A ; 这里跳走就完蛋</span><br><span class="line">0040114B |. E8 2B000000 CALL cycle.0040117B ; 注册成功对话框</span><br></pre></td></tr></table></figure>
<p>写到这准备跟踪算法时，才发现这个 crackme 还是挺复杂的，具体算法我就不写了，实在没那么多时间详细跟踪。有兴趣的可以跟一下，<strong>注册码是 17 位，用户名采用复制的方式扩展到 16 位，如我输入“CCDebuger”，扩展后就是“CCDebugerCCDebug”。大致是先取扩展后用户名的前 8 位和注册码的前 8 位，把用户名的前四位和后四位分别与注册码的前四位和后四位进行运算，算完后再把扩展后用户名的后 8 位和注册码的后 8 位分两部分，再与前面用户名和注册码的前 8 位计算后的值进行异或计算，最后结果等于 0 就成功</strong>。注册码的第 17 位我尚未发现有何用处。对于新手来说，可能这个 crackme 的难度大了一点。没关系，我们主要是学习 OllyDBG 的使用，方法掌握就可以了。</p>
<p>最后说明一下：</p>
<ol>
<li>这个程序在设置了消息断点后可以省略在代码段上设访问断点那一步，直接打开 RUN 跟踪，消息断点断下后按 <code>CTR+F12 组合键</code>让程序执行， RUN 跟踪记录中就可以找到关键地方。</li>
<li>对于这个程序，你可以不设消息断点，在输入用户名和注册码后先不按那个“Check”按钮，直接打开 RUN 跟踪，添加“所有函数过程的入口”后再回到程序中点“Check”按钮，这时在 OllyDBG 中打开 RUN 跟踪记录同样可以找到关键位置。  </li>
</ol>
<h2 id="汇编功能"><a href="#汇编功能" class="headerlink" title="汇编功能"></a>汇编功能</h2><p>今天我们的目标程序是 MyUninstaller 1.34 版。这是一个非常小的程序卸载工具， VC6 编写，大小只有61K。我拿到的这个是上次闪电狼兄弟给我的，附带在里面的简体中文语言文件是由六芒星制作的。这个程序有个毛病：就是在列出的可卸载程序上双击查看属性时，<strong>弹出的属性窗口的字体非常难看</strong>，应该就是系统字体（SYSTEM_FONT）：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002171853600.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002171853600.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002171853600"></p>
<p>我们今天的目标就是<strong>利用 OllyDBG 的汇编功能把上面显示的字体改成我们常见的 9 号（小五）宋体</strong>。首先我们用 OllyDBG 载入程序，按 <em>CTR+N 组合键</em>查找一下有哪些 API 函数，只发现一个和设置字体相关的 <strong>CreateFontIndirectA</strong>。现在我们按鼠标右键，选择“在每个参考上设置断点”，关掉名称对话框， F9 运行，程序已经运行起来了。我们在程序的列表框中随便找一项双击一下，很不幸，那个字体难看的界面又出现了， OllyDBG 没有任何动作。<strong>可见创建这个窗口的时候根本没调用 CreateFontIndirectA</strong>，问题现在就变得有点复杂了。先点确定把这个字体难看的对话框关闭，现在我们从另一个方面考虑：<strong>既然没有调用设置字体的函数，那我们来看看这个窗口是如何创建的</strong>，跟踪窗口创建过程可能会找到一些对我们有用的信息。现在我们再回到我们调试程序的领空，按 <strong>CTR+N 看一下，发现 CreateWindowExA 这个 API 函数比较可疑</strong>。我们在 <strong>CreateWindowExA 函数的每个参考上设上断点</strong>，在 <strong>MyUninstaller 的列表框中再随便找一项双击一下</strong>，被 OllyDBG 断下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \断在这里</span><br></pre></td></tr></table></figure>
<p>上下翻看一下代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">00408F3B |. 50 |PUSH EAX ; |hInst</span><br><span class="line">00408F3C |. 8B45 C0 |MOV EAX,DWORD PTR SS:[EBP-40] ; |</span><br><span class="line">00408F3F |. 6A 00 |PUSH 0 ; |hMenu = NULL</span><br><span class="line">00408F41 |. 03C6 |ADD EAX,ESI ; |</span><br><span class="line">00408F43 |. FF75 08 |PUSH DWORD PTR SS:[EBP+8] ; |hParent</span><br><span class="line">00408F46 |. FF75 D0 |PUSH DWORD PTR SS:[EBP-30] ; |Height</span><br><span class="line">00408F49 |. 57 |PUSH EDI ; |Width</span><br><span class="line">00408F4A |. 50 |PUSH EAX ; |Y</span><br><span class="line">00408F4B |. FF75 BC |PUSH DWORD PTR SS:[EBP-44] ; |X</span><br><span class="line">00408F4E |. FF75 EC |PUSH DWORD PTR SS:[EBP-14] ; |Style</span><br><span class="line">00408F51 |. 68 80DE4000 |PUSH myuninst.0040DE80 ; |WindowName = &quot;&quot;</span><br><span class="line">00408F56 |. 68 DCD94000 |PUSH myuninst.0040D9DC ; |Class = &quot;STATIC&quot;</span><br><span class="line">00408F5B |. FF75 D4 |PUSH DWORD PTR SS:[EBP-2C] ; |ExtStyle</span><br><span class="line">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \断在这里</span><br><span class="line">00408F64 | 6A 00 |PUSH 0 ; 第一处要修改的地方</span><br><span class="line">00408F66 | 8945 F4 |MOV DWORD PTR SS:[EBP-C],EAX</span><br><span class="line">00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E&gt;</span><br><span class="line">00408F6E |. 50 |PUSH EAX ; |hInst</span><br><span class="line">00408F6F |. 8B45 DC |MOV EAX,DWORD PTR SS:[EBP-24] ; |</span><br><span class="line">00408F72 |. 6A 00 |PUSH 0 ; |hMenu = NULL</span><br><span class="line">00408F74 |. 03F0 |ADD ESI,EAX ; |</span><br><span class="line">00408F76 |. FF75 08 |PUSH DWORD PTR SS:[EBP+8] ; |hParent</span><br><span class="line">00408F79 |. FF75 CC |PUSH DWORD PTR SS:[EBP-34] ; |Height</span><br><span class="line">00408F7C |. 53 |PUSH EBX ; |Width</span><br><span class="line">00408F7D |. 56 |PUSH ESI ; |Y</span><br><span class="line">00408F7E |. FF75 D8 |PUSH DWORD PTR SS:[EBP-28] ; |X</span><br><span class="line">00408F81 |. FF75 E8 |PUSH DWORD PTR SS:[EBP-18] ; |Style00408F84 |. 68 80DE4000 |PUSH myuninst.0040DE80 ; |WindowName = &quot;&quot;</span><br><span class="line">00408F89 |. 68 D4D94000 |PUSH myuninst.0040D9D4 ; |Class = &quot;EDIT&quot;</span><br><span class="line">00408F8E |. FF75 B8 |PUSH DWORD PTR SS:[EBP-48] ; |ExtStyle</span><br><span class="line">00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \CreateWindowExA</span><br><span class="line">00408F97 | 8945 F0 |MOV DWORD PTR SS:[EBP-10],EAX ; 第二处要修改的地方</span><br><span class="line">00408F9A | 8B45 F8 |MOV EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line">00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX] ; /&lt;%s&gt;</span><br><span class="line">00408F9F |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150] ; |</span><br><span class="line">00408FA5 |. 68 D0D94000 |PUSH myuninst.0040D9D0 ; |format = &quot;%s:&quot;</span><br><span class="line">00408FAA |. 50 |PUSH EAX ; |s</span><br><span class="line">00408FAB |. FF15 90B14000 |CALL DWORD PTR DS:[&lt;&amp;MSVCRT.sprintf&gt;] ; \</span><br><span class="line">sprintf</span><br><span class="line">00408FB1 |. 8B35 84B24000 |MOV ESI,DWORD PTR DS:[&lt;&amp;USER32.SetWindowTextA&gt;] ; USER32.SetWindowTextA</span><br><span class="line">00408FB7 |. 83C4 0C |ADD ESP,0C</span><br><span class="line">00408FBA |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150]</span><br><span class="line">00408FC0 |. 50 |PUSH EAX ; /Text</span><br><span class="line">00408FC1 |. FF75 F4 |PUSH DWORD PTR SS:[EBP-C] ; |hWnd</span><br><span class="line">00408FC4 |. FFD6 |CALL ESI ; \SetWindowTextA</span><br><span class="line">00408FC6 |. 8D85 ACFAFFFF |LEA EAX,DWORD PTR SS:[EBP-554]</span><br><span class="line">00408FCC |. 50 |PUSH EAX ; /Arg3</span><br><span class="line">00408FCD |. FF75 FC |PUSH DWORD PTR SS:[EBP-4] ; |Arg2</span><br><span class="line">00408FD0 |. FF35 00EF4000 |PUSH DWORD PTR DS:[40EF00] ; |Arg1 = 00BEADCC</span><br><span class="line">00408FD6 |. E8 1884FFFF |CALL &lt;myuninst.sub_4013F3&gt; ; \sub_4013F300408FDB |. 83C4 0C |ADD ESP,0C</span><br><span class="line">00408FDE |. 50 |PUSH EAX</span><br><span class="line">00408FDF |. FF75 F0 |PUSH DWORD PTR SS:[EBP-10]</span><br><span class="line">00408FE2 |. FFD6 |CALL ESI</span><br><span class="line">00408FE4 |. FF45 FC |INC DWORD PTR SS:[EBP-4]</span><br><span class="line">00408FE7 |. 8345 F8 14 |ADD DWORD PTR SS:[EBP-8],14</span><br><span class="line">00408FEB |. 837D FC 0F |CMP DWORD PTR SS:[EBP-4],0F</span><br><span class="line">00408FEF |.^ 0F8C 32FFFFFF \JL &lt;myuninst.loc_408F27&gt;</span><br><span class="line">00408FF5 |. 5F POP EDI</span><br><span class="line">00408FF6 |. 5E POP ESI</span><br><span class="line">00408FF7 |. 5B POP EBX</span><br><span class="line">00408FF8 |. C9 LEAVE</span><br><span class="line">00408FF9 \. C3 RETN</span><br></pre></td></tr></table></figure>
<p>我想上面的代码我不需多做解释， OllyDBG 自动给出的注释已经够清楚的了。我们双击 MyUninstaller 列表框中的的某项查看属性时，弹出的属性窗口上的 <strong>STATIC 控件和 EDIT 控件都是由 CreateWindowExA 函数创建的</strong>，然后再<strong>调用 SetWindowTextA 来设置文本</strong>，<strong>根本没考虑控件上字体显示的问题</strong>，所以我们看到的都是系统默认的字体。我们要设置控件上的字体，<strong>可以考虑在 CreateWindowExA 创建完控件后，在使用SetWindowTextA 函数设置文本之前调用相关字体创建函数来选择字体</strong>，再<strong>调用 SendMessageA 函数发送 WM_SETFONT 消息来设置控件字体</strong>。</p>
<p>思路定下来后，我们就开始来实施。首先我们看一下这个程序中的导入函数， CreateFontIndirectA 这个字体创建函数已经有了，再看看 SendMessageA，呵呵，不错，原程序也有这个函数。这样我们就省事了。有人可能要问，<strong>如果原来并没有这两个导入函数，那怎么办呢</strong>？其实这也很简单，我们可以直接<strong>用 LordPE 来在程序中添加我们需要的导入函数</strong>。我这里用个<strong>很小的 PE 工具 zeroadd 来示范一下</strong>，这个程序里面没有 CreateFontIndirectA 和 SendMessageA 函数（这里还有个问题说一下，其实<strong>我们编程时调用这两个函数时都是直接写 CreateFontIndirect 及 SendMessage，一般不需指定</strong>。但在程序中写补丁代码时我们要指定这是什么类型的函数。这里在函数后面加个“A”表示这是 ASCII 版本，同样 UNICODE 版本在后面加个“W”，如 SendMessageW。在 Win9X 下我们一般都用 ASCII 版本的函数， UNICODE 版本的函数很多在 Win9X 下是不能运行的。而 NT 系统如 WinXP 一般都是 UNICODE 版本的，但如果我们用了 ASCII 版本的函数，系统会自动转换调用 UNICODE 版本。这样我们写补丁代码的时候就可以直接指定为 ASCII 版本的函数，可以兼容各个系统）：我们用 LordPE 的 PE 编辑器载入 zeroadd 程序，选择“目录”，再在弹出的目录表对话框中选择输入表后面的那个“…”按钮，会弹出一个对话框：</p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002174344625.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002174344625.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002174344625"></p>
<p>因为 SendMessageA 在 USER32.dll 中，我们在右键菜单中点击按钮“添加导入表”，来到下面：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002180507178.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002180507178.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002180507178"></p>
<p>按上面的提示完成后点“确定”，我们回到原先的那个“输入表”对话框：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002180306282.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002180306282.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002180306282"></p>
<p>从上图中<strong>我们可以看出多出了一个 USER32.dll</strong>，这就是我们添加 SendMessageA 的结果。这也是<strong>用工具添加的一个缺点</strong>。我们一般希望把添加的函数直接放到已存在的 DLL 中，而不是多出来一个，这样显得不好看。但用工具就没办法， <strong>LordPE 默认是建一个 1K 的新区段来保存添加后的结果</strong>，由此出现了上图中的情况。如果你对 PE 结构比较熟悉的话，也可以直接用 16 进制编辑工具来添加你需要的函数，这样改出来的东西好看。如果想偷懒，就像我一样用工具吧，呵呵。</p>
<p>在上图中我还标出了要注意 <strong>FirstThunk</strong> 及那个 <strong>ThunkRVA</strong> 的值，并且要把“<strong>总是查看 FirstThunk</strong>”那个选项选上。</p>
<p>有人可能不理解其作用，我这里也解释一下：一般讲述 PE 格式的文章中对 FirstThunk 的解释是这样的： FirstThunk 包含指向一个IMAGE_THUNK_DATA 结构数组的 RVA 偏移地址，当把 PE 文件装载到内存中时， PE 装载器将查找 IMAGE_THUNK_DATA 和IMAGE_IMPORT_BY_NAME 这些结构数组来决定导入函数的地址，随后用导入函数真实地址来替代由 FirstThunk 指向的 IMAGE_THUNK_DATA 数组里的元素值。</p>
<p>这样说起来还是让人不明白，我举个例子：比如你有个很要好的朋友，他是个大忙人，虽然你知道他的家庭住址，可他很少回家。如果你哪天想找他，直接去他家，很可能吃个闭门羹，找不到他人。怎么办？幸好你有他的手机号码，你就给他拨了一个电话： “小子，你在哪呢？ ”，他告诉你： “我正在 XXX 饭店喝酒呢！ ”这时你怎么办？（当然是杀到他说的那家饭店去蹭饭了！ ^_^）这里的 <strong>ThunkRVA 就相当于你朋友的手机号码</strong>， <strong>SendMessageA 就相当于你那个朋友</strong>。而 <strong>FirstThunk 就是你手机里的号码分组</strong>。你把你的多个朋友都放在 FirstThunk 这样的号码分组里，每个 ThunkRVA 就是你一个朋友的手机号码。你要找他们，就是通过 ThunkRVA 这样的手机号码来和他们联系，直接去他家找他你很可能要碰壁。而<strong>移动或联通就相当于操作系统</strong>，他们<strong>负责把你的手机号码和你的朋友对应上</strong>。而 FirstThunk 这样的号码分组还有一个好处就是你可以不记你某个朋友的具体号码，只要记得 FirstThunk 号码分组的值，你的朋友会按顺序在里面排列。比如上图中 USER32.dll 中的第一个函数是 SendMessageA，它的 ThunkRVA 值就是 FirstThunk 值。<strong>如果还有第二个函数，比如是 MessageBoxA，它的值就是 FirstThunk 值加上 4</strong>，其余推。你只要记住各个函数的位置，也可以通过 FirstThunk 加上位置对应值来找到它。当然这比不上直接看 ThunkRVA 来得方便。</p>
<p>说了上面这些，我们就要考虑怎么在程序中调用了。你可能会说，我在 OllyDBG 中直接在我们要修改的程序中这样调用： CALL SendMessageA。哦，别这样。这等于我上面说的都是废话，会让我感到伤心的。你这里的 <strong>CALL SendMessageA 就相当于也不跟你朋友打个招呼就直接去他家找他，很有可能你会乘兴而去，败兴而归</strong>。别忘了他的手机号码，我们<strong>只有通过号码才知道他到底在什么地方</strong>。我们应该这样： <strong>CALL DWORD PTR [40B01A]</strong>，<strong>这里的 40B01A 就是上面的 SendMessageA 在程序载入后的所在的地方</strong>，<strong>由基址 00400000 加上 ThunkRVA 0000B01A 得到的</strong>。这就是你要找的人所在的地方，不管他跑到哪，你有他的手机号码就能找到他。同样道理，你<strong>只要记住了 ThunkRVA 值，就按这个来调用你需要的函数</strong>，在<strong>别的 Windows 系统下也是没有问题</strong>的。<strong>系统会自动把你要找到函数和 ThunkRVA 值对应上</strong>。而你在 OllyDBG 中写 CALL SendMessageA，可能你在你的系统上成功了，可放到别的系统下就要出错了。为什么？因为你找的人已经不在原来的位置了，他跑到别的地方去了。你还到老地方找他，当然看不见人了。说了这么多废话，也不知大家听明白了没有，别越听越糊涂就行了。总之一句话，<strong><em>别像 CALL SendMessageA 这样直接调用某个函数，而应该通过 ThunkRVA 值来调用它</em></strong>。</p>
<p>下面我们回到我们要修改的 MyUninstaller 上来，先用 LordPE打开看一下，呵呵，原来 CreateFontIndirectA 和 SendMessageA 原程序里面都有了，省了我们不少事情。看一下这两个函数的 ThunkRVA 值，CreateFontIndirectA 在 GDI32.dll 里面， ThunkRVA 值是 0000B044，这样我们就知道在程序中调用它的时候就是 CALL DWORD PTR[0040B044]。同样， SendMessageA 的 ThunkRVA 值是 0000B23C，调用时应该是这样： CALL DWORD PTR [0040B23C]。了解了这些东西我们就来考虑怎么写代码了。  </p>
<p>首先我们来看一下 CreateFontIndirectA 和 SendMessageA 这两个函数的定义：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CreateFontIndirectA：</span><br><span class="line"><span class="function">HFONT <span class="title">CreateFontIndirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	CONST LOGFONT *lplf <span class="comment">// pointer to logical font structure</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"><span class="comment">//CreateFontIndirect 的返回值就是字体的句柄。  </span></span><br></pre></td></tr></table></figure>
<p>对于这个函数我们需要的参数就是给它一个 <strong>LOGFONT 的字体结构指针</strong>，我们只要在要修改程序的空白处建一个标准的 9 号（小五）宋体的 LOGFONT 字体结构，再把指针给 CreateFontIndirectA 就可以了。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SendMessageA：</span><br><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd, <span class="comment">// handle of destination window</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT Msg, <span class="comment">// message to send</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam, <span class="comment">// first message parameter</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam <span class="comment">// second message parameter</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的<strong>第一个参数是窗口句柄</strong>，我们知道 <strong>CreateWindowExA 返回的就是窗口句柄</strong>，我们可以直接拿来用。<strong>第二个消息参数我们这里是设置字体</strong>，选 WM_SETFONT，这个值是 30H。<strong>第三个参数是字体句柄</strong>，可以<strong>由上面的 CreateFontIndirectA 获得</strong>。第四个参数我们不需要，留空。现在我们准备开始写代码，首先我们要在程序中建一个标准 9 号宋体的 LOGFONT，以便于我们调用。对于 LOGFONT，我们再来看一下定义：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLOGFONT</span> &#123;</span> <span class="comment">// lf</span></span><br><span class="line">    LONG lfHeight;</span><br><span class="line">    LONG lfWidth;</span><br><span class="line">    LONG lfEscapement;</span><br><span class="line">    LONG lfOrientation;</span><br><span class="line">    LONG lfWeight;</span><br><span class="line">    BYTE lfItalic;</span><br><span class="line">    BYTE lfUnderline;</span><br><span class="line">    BYTE lfStrikeOut;</span><br><span class="line">    BYTE lfCharSet;</span><br><span class="line">    BYTE lfOutPrecision;</span><br><span class="line">    BYTE lfClipPrecision;</span><br><span class="line">    BYTE lfQuality;</span><br><span class="line">    BYTE lfPitchAndFamily;</span><br><span class="line">    TCHAR lfFaceName[LF_FACESIZE];</span><br><span class="line">&#125; LOGFONT;</span><br></pre></td></tr></table></figure>
<p>这样我们的标准 9 号宋体的 LOGFONT 值应该是 32 字节， 16 进制就像这样：<code>F4FFFFFF000000000000000000000000900100000000008600000000CBCECCE5</code>.</p>
<p>现在在程序中找个空地。我们用 PEiD 来帮助我们寻找，用 PEiD 打开程序，点 EP 段后面的那个 &gt; 号，随便选择一个区段右击，选“搜索全0 处”（原版好像是 cave 什么的）：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002191206824.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002191206824.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002191206824"></p>
<p>我们看到 PEiD 把搜索到的空间都给我们列出来了：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002191245805.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002191245805.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002191245805"></p>
<p>现在我们用 WinHEX 打开我们要修改的程序，转到偏移 9815 处，从 9815 处选择 32 字节（16 进制是 0X20）的一个选块，把光标定位到 9815 处，右键选择菜单 剪贴板数据-&gt;写入(从当前位置覆写)，随后的格式选择 ASCII Hex，把我们 LOGFONT 的 16 进制值  <code>F4FFFFFF000000000000000000000000900100000000008600000000CBCECCE5</code>  写入保存。现在我们用 OllyDBG 载入已添加了 LOGFONT 数据的程序，先转到 VA 40A415 处（从上图中看到的）往下看一下：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002191423025.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002191423025.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002191423025"></p>
<p>因为 SendMessageA 还要用到一个窗口句柄，我们可以通过前面的 CreateWindowExA 来获得。现在我们就把前一张图中的 .rdata 区段中的地址 0040C56E 作为我们保存窗口句柄 HWND 值的临时空间。一切就绪，开始写代码。先回顾一下我们最先说的那两个要修改的地方：  </p>
<p>第一个要改的地方：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \CreateWindowExA</span><br><span class="line">00408F64 6A 00 PUSH 0 ; 修改前</span><br><span class="line">00408F66 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX</span><br><span class="line">00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E&gt;</span><br></pre></td></tr></table></figure>
<p>修改后：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \CreateWindowExA</span><br><span class="line">00408F64 E9 D5140000 JMP myuninst.0040A43E ; 跳转到我们的补丁代码处</span><br><span class="line">00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E&gt;</span><br></pre></td></tr></table></figure>
<p>第二个要改的地方：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \CreateWindowExA</span><br><span class="line">00408F97 8945 F0 MOV DWORD PTR SS:[EBP-10],EAX ; 改这里</span><br><span class="line">00408F9A 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line">00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX] ; /&lt;%s&gt;</span><br><span class="line">00408F9F |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150] ; |</span><br><span class="line">00408FA5 |. 68 D0D94000 |PUSH myuninst.0040D9D0 ; |format = &quot;%s:&quot;</span><br><span class="line">00408FAA |. 50 |PUSH EAX ; |s</span><br><span class="line">00408FAB |. FF15 90B14000 |CALL DWORD PTR DS:[&lt;&amp;MSVCRT.sprintf&gt;] ; \sprintf</span><br><span class="line">00408FB1 |. 8B35 84B24000 |MOV ESI,DWORD PTR DS:[&lt;&amp;USER32.SetWindowTextA&gt;] ; USER32.SetWindowTextA</span><br></pre></td></tr></table></figure>
<p>修改后：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \CreateWindowExA</span><br><span class="line">00408F97 E9 D4140000 JMP myuninst.0040A470 ; 跳到我们的第二部分补丁代码处</span><br><span class="line">00408F9C 90 NOP</span><br><span class="line">00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX] ; /&lt;%s&gt;</span><br><span class="line">00408F9F |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150] ; |</span><br><span class="line">00408FA5 |. 68 D0D94000 |PUSH myuninst.0040D9D0 ; |format = &quot;%s:&quot;</span><br><span class="line">00408FAA |. 50 |PUSH EAX ; |s</span><br><span class="line">00408FAB |. FF15 90B14000 |CALL DWORD PTR DS:[&lt;&amp;MSVCRT.sprintf&gt;] ; \sprintf</span><br><span class="line">00408FB1 |. 8B35 84B24000 |MOV ESI,DWORD PTR DS:[&lt;&amp;USER32.SetWindowTextA&gt;] ; USER32.SetWindowTextA</span><br></pre></td></tr></table></figure>
<p>这两个地方的修改都是把原代码改成跳转，跳到我们的补丁代码那继续执行。在修改之前先把原代码复制下来，以便恢复。我们在 OllyDBG 中按 CTR+G 组合键，来到 0040A43E 地址处，开始输补丁代码：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002193715185.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002193715185.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002193715185"></p>
<p>同样，我们也在 0040A470 地址处输入我们另一部分的补丁代码。两部分的补丁代码分别如下：  </p>
<p>补丁代码 1：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0040A43E 60 PUSHAD ; 保护现场</span><br><span class="line">0040A43F A3 6EC54000 MOV DWORD PTR DS:[40C56E],EAX ; 保存窗口句柄</span><br><span class="line">0040A444 68 15A44000 PUSH myuninst.0040A415 ; 传递字体句柄 LOGFONT</span><br><span class="line">0040A449 FF15 44B04000 CALL DWORD PTR DS:[&lt;&amp;GDI32.CreateFontIndirectA&gt;] ; GDI32.CreateFontIndirectA</span><br><span class="line">0040A44F 6A 00 PUSH 0 ; lParam 参数留空</span><br><span class="line">0040A451 50 PUSH EAX ; 字体句柄 LOGFONT</span><br><span class="line">0040A452 6A 30 PUSH 30 ; WM_SETFONT</span><br><span class="line">0040A454 8B0D 6EC54000 MOV ECX,DWORD PTR DS:[40C56E] ; 窗口句柄送 ECX0040A45A 51 PUSH ECX ; 压入窗口句柄参数</span><br><span class="line">0040A45B FF15 3CB24000 CALL DWORD PTR DS:[&lt;&amp;USER32.SendMessageA&gt;] ; USER32.SendMessageA</span><br><span class="line">0040A461 61 POPAD ; 恢复现场</span><br><span class="line">0040A462 6A 00 PUSH 0 ; 恢复原代码</span><br><span class="line">0040A464 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX</span><br><span class="line">0040A467 ^ E9 FDEAFFFF JMP myuninst.00408F69 ; 返回</span><br></pre></td></tr></table></figure>
<p>补丁代码 2：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0040A470 &gt; \60 PUSHAD</span><br><span class="line">0040A471 . A3 6EC54000 MOV DWORD PTR DS:[40C56E],EAX</span><br><span class="line">0040A476 . 68 15A44000 PUSH myuninst.0040A415 ; /pLogfont = myuninst.0040A415</span><br><span class="line">0040A47B . FF15 44B04000 CALL DWORD PTR DS:[&lt;&amp;GDI32.CreateFontIndirectA&gt;] ; \CreateFontIndirectA</span><br><span class="line">0040A481 . 6A 00 PUSH 0 ; /lParam = 0</span><br><span class="line">0040A483 . 50 PUSH EAX ; |wParam</span><br><span class="line">0040A484 . 6A 30 PUSH 30 ; |Message = WM_SETFONT</span><br><span class="line">0040A486 . 8B0D 6EC54000 MOV ECX,DWORD PTR DS:[40C56E] ; |</span><br><span class="line">0040A48C . 51 PUSH ECX ; |hWnd =&gt; NULL</span><br><span class="line">0040A48D . FF15 3CB24000 CALL DWORD PTR DS:[&lt;&amp;USER32.SendMessageA&gt;] ; \SendMessageA</span><br><span class="line">0040A493 . 61 POPAD</span><br><span class="line">0040A494 . 8945 F0 MOV DWORD PTR SS:[EBP-10],EAX</span><br><span class="line">0040A497 . 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line">0040A49A .^ E9 FEEAFFFF JMP myuninst.00408F9D</span><br></pre></td></tr></table></figure>
<p>补丁代码 2 因为与补丁代码 1 类似，我就不做详细解释了。现在我们的代码都写完了，现在我们开始保存我们的工作，<strong>选中我们修改的代码，点击鼠标右键</strong>，会出来一个菜单：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002195314425.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002195314425.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002195314425"></p>
<p>我们<strong>左键选所有修改</strong> <em>（当然选它了，要不然只会保存我们选定的这一部分。关于这个地方还要说一下，有的时候我们修改完程序选“复制到可执行文件”时只有“选择”菜单，没有“所有修改”菜单项。按 OllyDBG 帮助里关于备份功能的说法，好像是受内存块限制的，补丁功能也同样是这样。对于备份及补丁功能我用的比较少，并不是很了解，这方面的内容还是大家自己去研究吧，有什么好的心得也希望能共享一下。我遇到不能保存所有修改的情况就是先把补丁代码全部复制下来，同时利用二进制功能复制代码，先选一段补丁代码保存为文件，再用 OllyDBG 打开保存后的文件，转到相应位置分别把我们复制下来的补丁二进制代码粘贴上去后保存。纯属笨办法，当然你也可以用 HexView 这样的工具来修改代码）</em>，随后会出来一个“把选中的内容复制到可执行文件”的对话框，我们选“全部复制”，又出来一个对话框，我们在上面点右键，在弹出的菜单上选“保存文件”：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200108765.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200108765.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002200108765"></p>
<p>这时会出来一个另存文件的对话框，<strong>我们另选一个名字如 myuninst1.exe 来保存，不要直接覆盖原文件 myuninst.exe</strong>,以便于出错后好修改。现在关闭 OllyDBG，先不要急着运行刚刚修改过的文件，因为我们还有个地方要改一下。大家还记得我们在 .rdata 中用了个地方作为我们保存临时变量的地方吧？原先的 .rdata 段属性设置是不可写的，现在我们写入了数据，运行时是会出错的。现在我们要修改一下 .rdata 段的属性。用 LordPE 的 PE 编辑器打开我们修改后的程序，点“区段”按钮，在弹出的对话框中点击 .rdata 段，右键选择弹出菜单中的“编辑区段”：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200141381.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200141381.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002200141381"></p>
<p>在弹出的对话框中选标志后面那个“…”按钮：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200240062.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200240062.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002200240062"></p>
<p>现在我们把区段标志添加一个可写入的属性：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200250600.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200250600.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002200250600"></p>
<p>完成后按确定保存我们所做的工作，运行一下修改后的程序，呵呵，终于把字体改过来了：  </p>
<p><img src="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200300852.png" class="lazyload placeholder" data-srcset="/2022/10/02/OllyDBG%E5%AE%8C%E7%BE%8E%E6%95%99%E7%A8%8B-%E8%B6%85%E5%BC%BA%E5%85%A5%E9%97%A8%E7%BA%A7/image-20221002200300852.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20221002200300852"></p>
<p>如果你运行出错也没关系，用 OllyDBG 调试一下你修改后的程序，看看错在什么地方。这一般都是输入补丁代码时造成的，你只要看一下你补丁代码运行的情况就可以了。到这里我们的任务似乎也完成了，但细心的朋友可能会发现补丁代码 1 和补丁代码 2 前面的代码基本上是相同的。一个两个这样的补丁还好，如果要是多的话，这样重复就要浪费不少空间了，况且工作量也相应加大了。<strong>既然前面有很多代码都是重复的，为什么我们不把这些重复的代码做成一个子程序呢？</strong>这样调用起来要方便的多。下面我们把前面的补丁代码修改一下，我们先把补丁代码 1 的代码改成这样(重复部分代码)：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0040A43E 60 PUSHAD ; 保护现场</span><br><span class="line">0040A43F A3 6EC54000 MOV DWORD PTR DS:[40C56E],EAX ; 保存窗口句柄</span><br><span class="line">0040A444 68 15A44000 PUSH myuninst.0040A415 ; 我们建的 LOGFONT 对应指针</span><br><span class="line">0040A449 FF15 44B04000 CALL DWORD PTR DS:[&lt;&amp;GDI32.CreateFontIndirectA&gt;] ; GDI32.CreateFontIndirectA</span><br><span class="line">0040A44F 6A 00 PUSH 0 ; lParam 参数留空</span><br><span class="line">0040A451 50 PUSH EAX ; 字体句柄</span><br><span class="line">0040A452 6A 30 PUSH 30 ; WM_SETFONT</span><br><span class="line">0040A454 8B0D 6EC54000 MOV ECX,DWORD PTR DS:[40C56E] ; 窗口句柄</span><br><span class="line">0040A45A 51 PUSH ECX ; 窗口句柄压栈</span><br><span class="line">0040A45B FF15 3CB24000 CALL DWORD PTR DS:[&lt;&amp;USER32.SendMessageA&gt;] ; USER32.SendMessageA</span><br><span class="line">0040A461 61 POPAD ; 恢复现场</span><br><span class="line">0040A462 C3 RETN ; 返回  </span><br></pre></td></tr></table></figure>
<p>这样我们的子程序代码就写好了。现在我们再在子程序代码后面写上两个补丁代码，当然不要忘了改前面原程序中的跳转：  </p>
<p>修改后的补丁代码 1：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040A467 E8 D2FFFFFF CALL myuninst.0040A43E ; 调用子程序</span><br><span class="line">0040A46C 6A 00 PUSH 0 ; 恢复前面修改过的代码</span><br><span class="line">0040A46E 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX0040A471 ^ E9 F3EAFFFF JMP myuninst.00408F69 ; 返回继续执行</span><br></pre></td></tr></table></figure>
<p>修改后的补丁代码 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040A47A E8 BFFFFFFF CALL myuninst.0040A43E</span><br><span class="line">0040A47F 8945 F0 MOV DWORD PTR SS:[EBP-10],EAX</span><br><span class="line">0040A482 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line">0040A485 ^ E9 13EBFFFF JMP myuninst.00408F9D</span><br></pre></td></tr></table></figure>
<p>我在每个补丁代码片断间留了 4 个字节来分隔。同样，我们还要修改一下我们前面的跳转：<br>第一个要修改跳转的地方：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \断在这里</span><br><span class="line">00408F64 E9 FE140000 JMP myuninst.0040A467 ; 跳到我们的第一部分补丁代码处</span><br><span class="line">00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E&gt;</span><br></pre></td></tr></table></figure>
<p>第二个要修改跳转的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowExA&gt;] ; \CreateWindowExA</span><br><span class="line">00408F97 E9 DE140000 JMP myuninst.0040A47A ; 跳到我们的第二部分补丁代码处</span><br><span class="line">00408F9C 90 NOP</span><br><span class="line">00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX] ; /&lt;%s&gt;  </span><br></pre></td></tr></table></figure>
<p>修改好后保存，同样不要忘了再修改一下 .rdata 区段的属性。运行一下，一切 OK！  </p>
<blockquote>
<p>文章：OllyDBG 完美教程(超强入门级)  </p>
<p>作者：CCDebuger  </p>
<p>来源：看雪</p>
<p>入门逆向抄过来自己看</p>
</blockquote>

      </div>
      <div class="post-tags-categories">
        
        <div class="tags">
          
            <a href="/tags/OllyDBG/" class="">
              OllyDBG
            </a>
          
            <a href="/tags/%E7%A0%B4%E8%A7%A3%E5%85%A5%E9%97%A8/" class="">
              破解入门
            </a>
          
            <a href="/tags/%E8%B0%83%E8%AF%95%E4%B8%93%E7%94%A8%E5%B7%A5%E5%85%B7/" class="">
              调试专用工具
            </a>
          
            <a href="/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/" class="">
              反汇编
            </a>
          
        </div>
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>fireknight</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2022/10/02/OllyDBG完美教程-超强入门级/" target="_blank" title="OllyDBG完美教程(超强入门级)">http://example.com/2022/10/02/OllyDBG完美教程-超强入门级/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">





  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="/medias/rand8.jpg" class="lazyload placeholder" data-srcset="/medias/rand8.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" src="" alt="">
    </div>
    <a href="/2022/07/24/CVE-2021-21315-NodeJs%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">CVE-2021-21315 NodeJs命令注入漏洞复现</div>
      </div>
      <!-- <div class="content">
        CVE-2021-21315 NodeJs命令注入漏洞复现0x00 简介Node.js是一个基于Chrome V8引擎的
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    
      <div id="appDonate" class="post-donate">
  <div id="donate_board" class="donate_bar center" ref="donate">
    <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏" @click="showDialogDrawer()"></a>
  </div>
  <transition name="fade">
    <div 
      class="donate-box-mask"
      v-cloak 
      v-show="visible"
      @click="cancelDialogDrawer()"
    >
    </div>
  </transition>
  <transition name="bounce">
    <div class="donate-box" v-cloak v-show="visible">
      <div class="donate-box_close">
        <i class="fas fa-times" aria-hidden="true" @click="cancelDialogDrawer" pointer></i>
      </div>
      <div class="donate-box_title">
        <h4>
          你的赏识是我前进的动力
        </h4>
      </div>
      <div class="donate-box_tab">
        <div class="Alipay" pointer :class="{'active': tabActive === 'Alipay'}" @click="changeTabActive('Alipay')">
          支付宝
        </div>
        <div class="WeChatpay" pointer :class="{'active': tabActive === 'WeChatpay'}" @click="changeTabActive('WeChatpay')">
          微信
        </div>
      </div>
      <div class="donate-box_img">
        <div class="AlipayImg" v-show="tabActive === 'Alipay'">
          <img src="/medias/1.jpg" class="lazyload placeholder" data-srcset="/medias/1.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="支付宝打赏" />
        </div> 
        <div class="WeChatpayImg" v-show="tabActive === 'WeChatpay'">
          <img src="/medias/2.jpg" class="lazyload placeholder" data-srcset="/medias/2.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="微信打赏" />
        </div>
      </div>
    </div>
  </transition>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDonate',
    data: {
      visible: false,
      tabActive: 'Alipay',
      top: 0,
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        // function getScroll() {
        //   return {
        //     left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
        //     top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
        //   };
        // }
        this.top = $(document).scrollTop() // or getScroll().top
        // console.log('aa', $('.main-content'));
        body.style.cssText = 'overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
      changeTabActive(name) {
        this.tabActive = name;
      }
    },
    created() {}
  })
</script>
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <!-- 文章详情页右侧目录 -->

  <div class="toc-aside">
    <div class="toc-main">
      <div class="toc-aside-title">
        <i class="fas fa-list-ul" aria-hidden="true"></i><span>本文目录</span>
        
          <div class="toc-open-close">本文目录</div>
        
      </div>
      <div class="toc-content">
        <div class="toc"></div>
      </div>
    </div>
  </div>

  <!-- 手机端目录按钮 -->
  <div id="toc-mobile-btn">
    <i class="fas fa-list-ul" aria-hidden="true"></i>
  </div>


<script>
  function closeToc(init) {
    $(".toc-aside").css({'width': 0, 'padding': 0, 'transition': init ?  'noe' : 'width 0.3s' });
    $(".toc-content").css({'width': 0});
    $(".toc-aside-title span, .toc-aside-title i").css({'display': 'none'});
    $(".main-content").css({'width': '75%', 'margin-left': 'auto', 'margin-right': 'auto',});
  };
  function openToc() {
    $(".main-content").css({'width': '65%', 'margin-right': '10px', 'margin-left': 'calc(35% - 350px)'});
    $(".toc-aside").css({'width': '300px', 'padding': '0 10px', 'transition': 'width 0.3s'});
    $(".toc-content").css({'width': '300px'});
    $(".toc-aside-title span, .toc-aside-title i").css({'display': 'inline-block'});
  }
  function openBtnClickFn () {
    let openOrCloseBtn = $('.toc-aside .toc-aside-title .toc-open-close');
    let open = eval('' || 'true');
    openOrCloseBtn.click(function() {
      if (open) {
        closeToc();
        open = false;
      } else {
        openToc();
        open = true;
      }
    });
  };
  openBtnClickFn();
  initCloseTocWidth(true);

  function initCloseTocWidth(init) {
    if (window.innerWidth >= 992) {
      let isClose = false;
      isClose && closeToc(init)
    }
  }

  document.addEventListener('pjax:complete', function () {
    $(".toc-aside").css({'transition': 'no'});
  })
  document.addEventListener('pjax:complete', function () {
    openBtnClickFn();
  })
  
</script>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || '#453ead';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    
      <link rel="stylesheet" href="/js/aplayer/APlayer@1.10.1.min.css">
<style>
.aplayer .aplayer-lrc p {
  
  font-size: 12px;
  font-weight: 700;
  line-height: 16px !important;
}

.aplayer .aplayer-lrc p.aplayer-lrc-current {
  
  font-size: 15px;
  color: #42b983;
}


.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
  left: -66px !important;
}

.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
  left: 0px !important;
}


</style>
<meting-js  
  class=""
  server="tencent"
  type="playlist"
  id="8062553743"
  fixed='true'
  autoplay='true'
  theme='#42b983'
  loop='all'
  order='random'
  preload='auto'
  volume='0.7'
  list-folded='true'
>
</meting-js>

<!-- <style>
  #aplayer {
    position: fixed;
    left: 0;
    bottom: 300px;
  }
</style> -->
<script src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
<script src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    

    <!-- 图片放大 -->
    
      <script src="/js/fancybox/jquery.fancybox.min.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script>

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -80,
    headingsOffset: -($(window).height() * 0.4 - 45),
    positionFixedSelector: '.toc-main',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 100) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('toc-aside')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  }
</style> 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const headerMenuTransparent = true;
    if (!headerMenuTransparent) { return; }
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script type="text/javascript">
  var utteranceCommon = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceCommon.Theme = 'github-dark';
    } else {
      utteranceCommon.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceCommon.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceCommon.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>